[TOC]

### 网络总结

##### 1.在浏览器中输入URL并按下回车会发生什么？

###### (1)解析URL

首先浏览器会解析输入的是 **URL** 还是搜索关键词，如果不是正常的 URL 就会作为搜索关键词传给默认的搜索引擎。

###### (2)检查HSTS列表

浏览器检查自带的 "**预加载 HSTS**(HTTP 严格传输安全)" 列表，里面包含了浏览器**只使用 HTTPS** 进行连接的网站。如果请求的网站在**这个列表里，浏览器会使用 HTTPS** 而不是 HTTP 协议，否则请求会使用 **HTTP 协议**发送。

###### (3)DNS查询

浏览器**检查域名是否在缓存**当中。如果浏览器缓存中没有，就去查询本地 Hosts 文件中是否配置了域名。

如果依然没有，则向 DNS 服务器发送一条 DNS 查询请求。首先查询本地 DNS 服务器，如果 DNS 服务器和主机在**同一个子网内**，系统会按照下面的 **ARP 过程**对 DNS 服务器进行 **ARP 查询**。如果 **DNS 服务器和主机在不同的子网**，系统会按照下面的 ARP 过程对**默认网关进行查询**。

###### (4)ARP过程

要想发送 **ARP(地址解析协议) 广播**，需要有一个**目标 IP 地址**，同时还需要知道用于发送 ARP 广播的接口的 **MAC 地址**。首先查询 **ARP 缓存**，如果缓存命中，返回结果：目标 IP = MAC。

如果缓存没有命中：

- 查看**路由表**，看看目标 **IP 地址**是不是在本地路由表中的**某个子网**内。是的话使用跟那个子网相连的接口，否则使用与**默认网关相连的接口**。
- 查询选择的网络接口的 MAC 地址。
- 发送一个二层 ARP 请求：

**ARP Request:**

```http
Sender MAC: interface:mac:address:here
Sender IP: interface.ip.goes.here
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target.ip.goes.here
```

根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：

**直连**：如果和**路由器是直接连接**的，路由器会返回一个如下的 "ARP Reply"。

**交换机**：

- 如果连接到了一个**交换机**，交换机会检查本地 **CAM/MAC 表**，看看哪个端口有要找的那个 MAC 地址，如果没有找到，交换机会向所有其它**端口广播这个 ARP 请求**。
- 如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有想要查询的 MAC 地址的那个端口发送 ARP 请求。
- 如果路由器也 "连接" 在其中，它会返回一个 "ARP Reply"。

**ARP Reply：**

```http
Sender MAC: target:mac:address:here
Sender IP: target.ip.goes.here
Target MAC: interface:mac:address:here
Target IP: interface.ip.goes.here
```

现在有了 **DNS 服务器或者默认网关的 IP 地址**，可以继续 **DNS 请求**了：

- 使用 53 端口向 DNS 服务器发送 **UDP 请求包**，如果响应包太大，会使用 **TCP 协议**。
- 如果 DNS 服务器没有找到结果，它会发送一个**递归查询请求**，**一层一层向高层 DNS 服务器**做查询，如果找到会把结果返回。
- 主机收到 DNS 消息之后也会在本地进行**缓存**。

###### (5)使用套接字TCP连接

当浏览器得到了**目标服务器的 IP 地址**，以及 URL 中给出来**端口号**(http 协议默认端口号是 80，https 默认端口号是 443)，它会调用**系统库函数 socket**，请求一个 **TCP 流套接字**，对应的参数是 **AF_INET/AF_INET6 和 SOCK_STREAM** 。

- 这个请求首先被交给**传输层**，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取(Linux 下是 ip_local_port_range)。
- TCP segment 被送往**网络层**，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的 IP 地址以及本机的 IP 地址，把它封装成一个 IP packet。
- 这个 TCP packet 接下来会进入**链路层**，链路层会在**封包中加入 frame 头部**，里面包含了本地内置网卡的 MAC 地址以及**网关(本地路由器) 的 MAC 地址**。与前面一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。

到现在 **TCP 封包**已经准备好了，可以使用以太网、WIFi、蜂窝数据网络等进行**数据传输**。最终封包会到达管理**本地子网的路由器**。在那里出发，它会继续经过**自治区域**(AS) 的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从 IP 数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP 数据报头部的 TTL 域的值每经过一个**路由器就减 1**，如果封包的 **TTL 变为 0**，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器**丢弃**。

上面的**发送和接受**过程在 **TCP 连接期间会发生很多次**：

- 客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号。

- 服务器端接收到 SYN 包，如果它可以建立连接：服务器端选择它自己的初始序列号服务器端设置 SYN 位，表明自己选择了一个初始序列号服务器端把(客户端 ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包。

- 客户端通过发送下面一个封包来确认这次连接：自己的序列号 +1 接收端 ACK + 1 设置 ACK 位。

- 数据通过下面的方式传输：当一方发送了 N 个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N另一方确认接收到这个数据包(或者一系列数据包) 之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号。

- 关闭连接时：要关闭连接的一方发送一个 FIN 包另一方确认这个 FIN 包，并且发送自己的 FIN 包要关闭的一方使用 ACK 包来确认接收到了 FIN。


###### (6)TLS握手

- 客户端发送一个 "ClientHello" 消息到**服务器端**，消息中同时包含了它的 TLS(Transport Layer Security) 版本，可用的加密算法和压缩算法。
- 服务器端向客户端返回一个 "ServerHello" 消息，消息中包含了服务器端的 TLS 版本，服务器所选择的加密和压缩算法，以及 CA 机构签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥。
- 客户端根据自己的**信任 CA 列表**，**验证服务器端的证书是否可信**。如果认为可信，客户端会生成一串**伪随机数**，使用服务器的公钥加密它。这串随机数会**被用于生成新的对称密钥**。
- 服务器端使用自己的私钥解密上面提到的**随机数**，然后使用这串随机数生成自己的对称主密钥。
- 客户端发送一个 "Finished" 消息给服务器端，使用对称密钥加密这次通讯的一个散列值。
- 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 "Finished" 消息，也使用协商好的对称密钥加密。
- 从现在开始，接下来整个 TLS 会话都使用**对称秘钥**进行加密，传输应用层(HTTP) 内容。

###### (7)HTTP协议

如果浏览器是 Google 的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:

```http
GET / HTTP/1.1
Host: google.com
Connection: close
[其他头部]
```

"其他头部" 包含一系列由冒号分割开的键值对，它们的格式符合 HTTP 协议标准，它们之间由一个换行符分割开来。这里假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 "HTTP/1.1" 协议。HTTP/1.1 定义了 "关闭连接" 的选项 "close"，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：

> Connection: close

在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。

服务器端**返回一个响应码**，指示这次请求的状态，响应形式如下:

```http
200 OK
[响应头部]
```

然后是一个**换行**，接下来有效载荷(payload)，也就是 "www.google.com" 的 HTML 内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。

如果浏览器发送的 HTTP 头部包含了足够多的信息(例如包含了 Etag 头部)，以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:

```http
304 Not Modified
[响应头部]
```

这个响应没有有效载荷，**浏览器会从自己的缓存中取出想要的内容**。

在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到 **HTML 页面引入的所有资源**(图片，CSS，favicon.ico等等) 全部都获取完毕，区别只是头部的 **GET / HTTP/1.1** 会变成 GET /$(相对 www.google.com 的 URL) HTTP/1.1 。

如果 HTML 引入了 "www.google.com" 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。

###### (8)HTTP服务器请求处理

HTTPD(HTTP Daemon) 在服务器端处理请求并进行响应。最常见的 HTTPD 有 Linux 上的 **Apache 和 nginx**。

- HTTPD 接收请求，并对 URL 进行分析获取请求的 HTTP 方法与路径等。

- 服务器验证其上已经配置了 google.com 的虚拟主机。

- 服务器验证 google.com 接受 GET 方法。

- 服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)。

- 如果服务器安装了 URL 重写模块(例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite)，服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求。

- 服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 "/" ,会访问首页文件(可以重写这个规则，但这是最常用的)。

- 服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者。

###### (9)浏览器后续操作

当服务器提供了**资源**之后(HTML，CSS，JS，图片等)，浏览器会执行下面的操作：

- **解析**：HTML，CSS，JS。HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。通过遍历 DOM 节点树创建一个 "Frame 树" 或 "渲染树"，并计算每个节点的各个 CSS 样式值。
- **渲染**：构建 DOM 树 -> 渲染 -> 布局 -> 绘制。

之后浏览器即可展示渲染出来的请求结果。













