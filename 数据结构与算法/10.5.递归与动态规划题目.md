[TOC]

### 递归与动态规划题目

递归和动态规划都是将原问题**拆成多个子问题然后求解**，他们之间最本质的区别是，**动态规划保存了子问题的解**，避免重复计算。

#### 斐波那契数列类题目

#### 斐波那契数列【509.简单】

##### [1. 题目](https://leetcode-cn.com/problems/fibonacci-number/)

求斐波那契数列的**第 n 项**，n <= 39。

<img src="assets/1563521870748-1594445002958.png" alt="1563521870748" style="zoom:56%;" />

##### 2. 解题

如果使用**递归**求解，会**重复计算**一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被**重复计算**了。

<img src="assets/1563521902486-1594445004941.png" alt="1563521902486" style="zoom:50%;" />

递归是将一个问题划分成**多个子问题**求解，动态规划也是如此，但是**动态规划**会把子问题的**解缓存**起来，从而避免重复求解子问题。

```java
public int Fibonacci(int num) {
    // Base case
    if (num <= 1) return num;
    int[] res = new int[num + 1];
    // 初始化
    res[1] = 1;
    // 自底向上计算即可
    for (int i = 2; i <= num; i++) {
        res[i] = res[i - 1] + res[i - 2];
    }
    return res[num];
}
```

考虑到第 i 项只与第 **i - 1** 和第 **i - 2** 项有关，因此**只需要存储前两项**的值就能求解第 i 项，从而将**空间复杂度**由 O(N) 降低为 O(1)。

```java
public int Fibonacci2(int n) {
    if (n <= 1) return n;
    // 两个指针，一个前一个后
    int back = 0, front = 1;
    // 存放最终结果
    int res = 0;
    for (int i = 2; i <= n; i++) {
        res = back + front;
        back = front;
        front = res;
    }
    return res;
}
```

由于待求解的 n 小于 40，因此可以将前 40 项的结果**先进行计算**，之后就能以 **O(1)** 时间复杂度得到第 n 项的值。

```java
public class Solution {
    private int[] fib = new int[40];
	// 预先计算并缓存
    public Solution() {
        fib[1] = 1;
        for (int i = 2; i < fib.length; i++) {
            fib[i] = fib[i - 1] + fib[i - 2];
        }
    }

    public int Fibonacci(int n) {
        return fib[n];
    }
}
```

#### 跳台阶/爬楼梯【70.简单】

##### [1. 题目](https://leetcode-cn.com/problems/climbing-stairs/)

一只青蛙一次可以跳上 **1 级台阶**，也可以跳上 **2 级**。求该青蛙跳上一个 **n 级的台阶总共有多少种跳法**。

<img src="assets/1563521990341-1594445009253.png" alt="1563521990341" style="zoom:50%;" />

##### 2. 解题

当 **n = 1** 时，只有**一种**跳法：

<img src="assets/1563522011148-1594445010789.png" alt="1563522011148" style="zoom:50%;" />

当 **n = 2** 时，有**两种**跳法：

<img src="assets/1563522031061-1594445013540.png" alt="1563522031061" style="zoom:50%;" />

跳 n 阶台阶，可以**先跳 1 阶台阶**，**再跳 n-1** 阶台阶；或者**先跳 2 阶**台阶，再跳 **n-2 阶**台阶。而 n-1 和 n-2 阶台阶的跳法可以看成**子问题**，该问题的递推公式为：

<img src="assets/1563522045805-1594445016452.png" alt="1563522045805" style="zoom:50%;" />

**跳上 n 阶台阶，可以从 n - 1 处跳 1 步，也可以从 n - 2 处跳一步。**也可也看成是**裴波那契**类型的题目。

```java
public int JumpFloor(int n) {
    if (n <= 2) return n;
    int back = 1, front = 2;
    int res = 1;
    // 滚动计算
    for (int i = 2; i < n; i++) {
        res = back + front;
        back = front;
        front = res;
    }
    return res;
}
```

#### 变态跳台阶【简单】

##### 1. 题目

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也**可以跳上 n 级**。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

<img src="assets/1563522070330-1594445018755.png" alt="1563522070330" style="zoom:50%;" />

##### 2. 解题

###### (1) 动态规划

每个位置都是之前位置的结果的**和**。

```java
public int JumpFloorII(int target) {
    int[] dp = new int[target];
    Arrays.fill(dp, 1);
    for (int i = 1; i < target; i++) {
        // 当前值是前面所有值的和
        for (int j = 0; j < i; j++) {
            dp[i] = dp[i] + dp[j];
        }
    }
    return dp[target - 1];
}
```

###### (2) 数学推导

跳上 n-1 级台阶，可以从 **n-2 级跳 1 级**上去，也可以从 **n-3 级**跳 2 级上去...，那么

```java
f(n-1) = f(n-2) + f(n-3) + ... + f(0)
```

同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么

```java
f(n) = f(n-1) + f(n-2) + ... + f(0)
```

综上可得

```java
f(n) - f(n-1) = f(n-1)
```

即：

```java
f(n) = 2 * f(n-1)
```

所以 f(n) 是一个等比数列

```java
public int JumpFloorII(int target) {
    return (int) Math.pow(2, target - 1);
}
```

#### 母牛生产问题

题目描述：假设农场中**成熟的母牛每年都会生 1 头小母牛**，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 **3 年**之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的**数量**。第 i 年成熟的牛的**数量**为：

<img src="assets/1563524629986.png" alt="1563524629986" style="zoom:67%;" />

#### 信件错排

题目描述：有 **N 个 信 和 信封**，它们被打乱，求**错误装信方式**的数量。

定义一个**数组 dp 存储错误方式数量**，**dp[i] 表示前 i 个信和信封的错误方式数量**。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。**根据 i 和 k 是否相等**，有两种情况：

- **i == k，交换 i 和 k 的信后，它们的信和信封在正确的位置**，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)\*dp[i-2] 种错误装信方式。
- **i  != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置**，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)\*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：

<img src="assets/1563524614884.png" alt="1563524614884" style="zoom:67%;" />



### 数组DP类题目

#### 矩阵中的不同路径【62.中等】

##### [1. 题目](https://leetcode-cn.com/problems/unique-paths)

一个机器人位于一个 **m x n** 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问**总共有多少条不同的路径**？

![image-20200707161628832](assets/image-20200707161628832.png)

##### 2. 题解

###### (1) 动态规划法

令 **dp\[i][j]** 是到达 i, j 位置的**路径总数**。由于**某个位置只能从上方或者左方**到来，所以**路线数量就是上方和左方路线数量的和。**可得状态方程：

```java
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

初始化：对于第一行 dp\[0][j]，或者第一列 dp\[i][0]，由于**都是在边界**，所以**只能为 1**。

时间复杂度：O(m * n)，空间复杂度：O(m * n)

```java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    // 初始化第一行和第一列
    for (int i = 0; i < n; i++) dp[0][i] = 1;
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

**优化**：因为每次**只需要 dp\[i-1][j], dp\[i][j-1]**，所以可以只记录这两个数。

```java
public int uniquePaths2(int m, int n) {
    int[] pre = new int[n];
    int[] cur = new int[n];
    Arrays.fill(pre, 1);
    Arrays.fill(cur, 1);
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            cur[j] = cur[j - 1] + pre[j];
        }
        pre = cur.clone();
    }
    return pre[n - 1];
}
```

```java
public int uniquePaths4(int m, int n) {
    int[] res = new int[n];
    Arrays.fill(res, 1);
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            res[j] = res[j] + res[j - 1];
        }
    }
    return res[n - 1];
}
```

###### (2) 数学推导法

也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。

```java
public int uniquePaths3(int m, int n) {
    // 总共的移动次数
    int totalMove = m + n - 2;
    // 向下的移动次数
    int downMove = m - 1;
    long res = 1;
    for (int i = 1; i <= downMove; i++) {
        res = res * (totalMove - downMove + i) / i;
    }
    return (int) res;
}
```

#### 矩阵最小路径和【64.中等】

##### [1. 题目](https://leetcode-cn.com/problems/minimum-path-sum)

给定一个包含非负整数的 m x n 网格，请找出一条从**左上角到右下角**的路径，使得路径上的**数字总和为最小**。

说明：每次只能向下或者向右移动一步。示例：

````java
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。
````

也可以求**最大**路径和，差不多的。

##### 2. 题解

类似上一题！只不过这里 dp 数组表示的是到达  m, n 坐标时的最小的和。

这里状态方程为：

```java
dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
```

```java
public int minPathSum(int[][] nums) {
    int row = nums.length;
    int col = nums[0].length;
    if (row == 0 || col == 0) return 0;

    int[][] dp = new int[row][col];
    // 初始化第一行第一列
    dp[0][0] = nums[0][0];
    for (int i = 1; i < row; i++) {
        dp[i][0] = dp[i - 1][0] + nums[i][0];
    }
    for (int j = 1; j < col; j++) {
        dp[0][j] = dp[0][j - 1] + nums[0][j];
    }
    for (int i = 1; i < row; i++) {
        for (int j = 1; j < col; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + nums[i][j];
        }
    }
    return dp[row - 1][col - 1];
}
```

可以用一个**一维数组**来代替二维数组优化空间。

```java
public int minPathSum2(int[][] nums) {
    // Base case
    if (nums.length == 0 || nums[0].length == 0) return 0;
    int col = nums.length, row = nums[0].length;
    int[] dp = new int[row];
    for (int i = 0; i < col; i++) {
        for (int j = 0; j < row; j++) {
            // 只能从上侧走到该位置
            if (j == 0) {
                dp[j] = dp[j];
            } else if (i == 0) {
                // 只能从左侧走到该位置
                dp[j] = dp[j - 1];
            } else {
                dp[j] = Math.min(dp[j - 1], dp[j]);
            }
            dp[j] = dp[j] + nums[i][j];
        }
    }
    return dp[row - 1];
}
```

#### 数组区间和【303.简单】

##### [1. 题目](https://leetcode-cn.com/problems/range-sum-query-immutable)

给定一个整数数组  nums，**求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和**，包含 i,  j 两点。示例：

```java
给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()
sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```

说明：你可以假设数组**不可变**。会**多次调用 sumRange 方法**。

##### 2. 题解

求区间 i \~ j 的和，可以**转换为 sum[j + 1] - sum[i]**，其中 **sum[i] 为 0 \~ i - 1** 的和。由于需要多次计算，所以先**滚动计算**出各个位置之前的和。

```java
// 存放计算好的和
private int[] sums;

public NumArray(int[] nums) {
    sums = new int[nums.length + 1];
    for (int i = 1; i <= nums.length; i++) {
        // 滚动计算数组和
        sums[i] = sums[i - 1] + nums[i - 1];
    }
}

public int sumRange(int i, int j) {
    return sums[j + 1] - sums[i];
}
```

#### 数组中等差递增子区间的个数【413.中等】

##### [1. 题目](https://leetcode-cn.com/problems/arithmetic-slices/)

如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，以下数列为等差数列:

```java
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
```

以下数列不是等差数列。

```java
1, 1, 2, 5, 7
```


数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：**元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q** 。函数要返回数组 A 中所有为等差数组的子数组个数。

```html
A = [1, 2, 3, 4]
返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
```

##### 2. 题解

首先创建一个大小为 n 的一维数组 dp。dp[i] 用来存储在区间 (k,i)， 而不在区间 (k,j) 中等差数列的个数，其中 j<i。

与递归方法中后向推导不同，前向推导 dp 中的值。其余的思路跟上一个方法几乎一样。对于第 i 个元素，判断这个元素跟前一个元素的差值是否和等差数列中的差值相等。如果相等，那么新区间中等差数列的个数即为 1+dp[i-1]。sum 同时也要加上这个值来更新全局的等差数列总数。

```java
public int numberOfArithmeticSlices(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int n = nums.length;
    int[] dp = new int[n];
    for (int i = 2; i < n; i++) {
        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {
            dp[i] = dp[i - 1] + 1;
        }
    }
    // 将dp数组全部加起来
    int total = 0;
    for (int cnt : dp) {
        total = total + cnt;
    }
    return total;
}
```

#### 打家劫舍【198.简单】

##### [1. 题目](https://leetcode-cn.com/problems/house-robber)

你是一个专业的小偷，计划偷窃**沿街**的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果**两间相邻的房屋在同一晚上被小偷闯入**，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，**一夜之内能够偷窃到的最高金额**。

```java
示例 1：输入：[1,2,3,1]  输出：4  解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。

输入：[2,7,9,3,1]  输出：12  解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

##### 2. 题解

定义 **dp 数组**用来存储**最大的抢劫量**，其中 dp[i] 表示抢到**第 i 个住户时**的最大抢劫量。由于不能抢劫邻近住户，如果抢劫了**第 i -1** 个住户，那么就不能再抢劫**第 i 个**住户，所以

<img src="assets/1563524592350.png" alt="1563524592350" style="zoom:67%;" />

```java
public int rob(int[] nums) {

    // Base case
    if (nums == null || nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    int[] dp = new int[nums.length];
    // 初始化DP
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for(int i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[dp.length - 1];
}
```

由于是可以进行**滚动计算**的，所以不需要 dp 这么大的空间，类似斐波那契数列，只需要维护两个变量记录当前变量的**前两个位置即可**。可以优化如下。

```java
public int rob2(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int length = nums.length;
    if (length == 1) return nums[0];
    // 使用两个变量记录之前的位置
    int slow = nums[0], fast = Math.max(nums[0], nums[1]);
    for (int i = 2; i < length; i++) {
        int temp = fast;
        fast = Math.max(slow + nums[i], fast);
        slow = temp;
    }
    return fast;
}
```

#### 打家劫舍II【213.中等】

##### [1. 题目](https://leetcode-cn.com/problems/house-robber-ii)

题目跟上题一样，只不过条件改成**所有的房屋都围成一圈**。

```java
示例 1: 输入: [2,3,2] 输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
    
示例 2: 输入: [1,2,3,1] 输出: 4
解释: 可以先偷窃1号房屋（金额=1），然后偷窃3号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。
```

##### 2. 题解

**环状排列**意味着**第一个房子和最后一个房子**中只能**选择一个**偷窃，因此可以把此环状排列房间问题**约化为两个单排排列房间子问题**：

- 在**不偷窃第一个房子**的情况下（即 nums[1:]），最大金额是 P1；
- 在**不偷窃最后一个房子**的情况下（即 nums[:n-1]），最大金额是 P2。

**综合偷窃最大金额**： 为以  上两种情况的较大值，即 **max(p1, p2)**。

```java
public int rob(int[] nums) {
    // Base case
    if (nums == null || nums.length == 0) return 0;
    int len = nums.length;
    if (len == 1) return nums[0];
    // 不偷窃第一个房子和不偷窃最后一个房子取较大值
    return Math.max(normalRob(nums, 0, len - 2), normalRob(nums, 1, len - 1));
}

// 指定范围的打家劫舍
private int normalRob(int[] nums, int start, int end) {
    int slow = 0, fast = 0;
    for (int i = start; i <= end; i++) {
        int temp = Math.max(fast, slow + nums[i]);
        slow = fast;
        fast = temp;
    }
    return fast;
}
```

#### 打家劫舍III【214.中等】

##### [1. 题目](https://leetcode-cn.com/problems/house-robber-iii/)

在上次打劫完**一条街道之后和一圈房屋**后，小偷又发现了一个**新的可行窃的地区**。这个地区**只有一个入口**，我们称之为“**根**”。 除了“根”之外，**每栋房子有且只有一个“父“房子与之相连**。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于**一棵二叉树**”。 如果**两个直接相连的房子在同一天晚上被打劫，房屋将自动报警**。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

```java
输入: [3,2,3,null,3,null,1]
     3
    / \
   2   3
    \   \ 
     3   1
输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

##### 2. 题解

**树形 dp 的套路解**，不过有点复杂。

```java
public int rob(TreeNode root) {
    int[] res = dfs(root);
    return Math.max(res[0], res[1]);
}

private int[] dfs(TreeNode node) {
    // Base case
    if (node == null) return new int[]{0, 0};

    // 分类讨论的标准是：当前结点偷或者不偷
    // 由于需要后序遍历，所以先计算左右子结点，然后计算当前结点的状态值
    int[] left = dfs(node.left);
    int[] right = dfs(node.right);

    // dp[0]：以当前node为根结点的子树能够偷取的最大价值，规定node结点不偷
    // dp[1]：以当前node为根结点的子树能够偷取的最大价值，规定node结点偷
    int[] dp = new int[2];

    dp[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    dp[1] = node.val + left[0] + right[0];
    return dp;
}
```

#### 使用最小花费爬楼梯【746.简单】

##### [1. 题目](https://leetcode-cn.com/problems/min-cost-climbing-stairs)

数组的每个索引作为一个阶梯，**第 i 个阶梯**对应着一个非负数的体力花费值 **cost\[i]** (索引从 0 开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。请找到达到楼层**顶部**的最低花费。在开始时，可以选择从**索引为 0 或 1 的元素**作为**初始阶梯**。

```java
输入: cost = [10, 15, 20] 输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。

输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
```

##### 2. 题解

###### (1) 动态规划法

**dp[i]** 意为爬到**第 i 级**需要的**最小**花费。题意中的**第 0 级和第 1 级**是不需要花费体力即可到达的（见题目示例 1，可直接从 cost[1] 开始，即到达第 1 级**不需要**花费）。这里有 **dp[0] = 0; dp[1] = 0**。
对于爬到第 i 级需要的最小体力，可以选择从**第 i - 1 级往上爬一步**到达，也可以选择从**第 i - 2 级往上爬两步**到达。前者需要的体力等于爬到第 i - 1 级需要的最小体力 dp[i - 1] 再加上从第 i - 1 级往上爬要耗费的体力 cost[i - 1]，同理也可以得到后者需要的体力，这两者的较小者就是爬到第 i 级需要的最小体力。因此可得状态转移方程：

```java
dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);
```

```java
public int minCostClimbingStairs(int[] cost) {
    // dp[0] dp[1] 默认为0
    int[] dp = new int[cost.length + 1];
    for(int i = 2; i < dp.length; i++) {
        // 选择一步到达或者两步到达的较小值
        dp[i] = Math.min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);
    }
    return dp[dp.length - 1];
}
```

这里也可以滚动计算**优化空间**。

```java
public int minCostClimbingStairs2(int[] cost) {
    int f1 = 0, f2 = 0;
    for (int i = 0; i < cost.length; i++) {
        int minCost = cost[i] + Math.min(f1, f2);
        f1 = f2;
        f2 = minCost;
    }
    return Math.min(f1, f2);
}
```

#### 买卖股票的最佳时机【121.简单】

##### [1. 题目](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

给定一个**数组**，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多**只允许完成一笔交易**（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。注意：你不能在买入股票前卖出股票。

```java
输入: [7,1,5,3,6,4] 输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
    
输入: [7,6,4,3,1] 输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

##### 2. 题解

使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i **之前并且价格最低**。

<img src="assets/image-20200707171814356.png" alt="image-20200707171814356" style="zoom:67%;" />

使用 **soFarMin** 记录到目前为止遇到过的最低价格。新的一天时，就看是否价格更低，同时看与 soFarMin 之间的差值是否更大。

```java
public int maxProfit(int prices[]) {
    // 到目前为止的最小价格
    int soFarMin = Integer.MAX_VALUE;
    // 记录最大利润
    int max = 0;
    // 遍历更新这个值
    for (int i = 0; i < prices.length; i++) {
        // 更新最大利润
        max = Math.max(max, prices[i] - soFarMin);
        // 更新最小价格
        soFarMin = Math.min(soFarMin, prices[i]);
    }
    return max;
}
```

#### 除数博弈【1025.简单】

##### [1. 题目](https://leetcode-cn.com/problems/divisor-game)

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个**数字 N** 。在每个玩家的回合，玩家需要执行以下操作：

- 选出任一 x，满足 0 < x < N 且 **N % x == 0** 。
- 用 **N - x 替换**黑板上的数字 N 。

如果玩家无法执行这些操作，就会输掉游戏。只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以**最佳状态**参与游戏。

```java
输入：2 输出：true 解释：爱丽丝选择 1，鲍勃无法进行操作。
输入：3 输出：false 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
```

##### 2. 题解

###### (1) 归纳法

观察：谁**先从 2 的基础减去 1 谁胜**。统计**能取模的次数**，**次数为奇数则 Alice 赢，返回 true**。

- 最终结果应该是占到 2 的赢，占到 1 的输；
- 若当前为奇数，奇数的约数只能是奇数或者 1，因此下一个一定是偶数；
- 若当前为偶数， 偶数的约数可以是奇数可以是偶数也可以是 1，因此直接减 1，则下一个是奇数；
- 因此，奇则输，偶则赢。

直接写出：

```java
public boolean divisorGame(int N) {
    return N % 2 == 0;
}
```

###### (2) 动态规划法

将所有的**小于等于 N 的解**都找出来，基于前面的，递推后面的。状态转移: 如果 **i 的约数**里面有存在为 False 的（即输掉的情况），则当前 i 应为 True；如果没有，则为 False。

求出**所有 3-N** 的因子，比较大小：

- 若得 0（即**可以给别人一个 0**），说明拿到该值**必胜**，将该值转化为 1；

- 若得 1（即**必须给别人一个 1**），说明拿到该值**必输**，将该值转化为 0；

补充：为了让 dp[i] 的 i 与 N 对应，给不会出现的 dp[0] 和 dp[1] 一个极大值。

```java
public boolean divisorGame(int N) {
    if (N == 1) return false;
    if (N == 2) return true;
    boolean[] dp = new boolean[N + 1];
    dp[1] = false;
    dp[2] = true;
    for (int i = 3; i <= N; i++) {
        for (int j = 1; j < i; j++) {
            if (i % j == 0 && !dp[i - j]) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[N];
}
```



### 字符串与序列类题目

#### 数组最大连续子序列和【53.简单】

##### [1. 题目](https://leetcode-cn.com/problems/maximum-subarray)

给定一个**整数数组 nums** ，找到一个具有**最大和的连续子数组**（子数组最少包含一个元素），返回其**最大和**。这里肯定 要求是连续的子序列，如果不是那直接把全部正数加起来就行了。示例：

```java
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

进阶：如果你已经实现**复杂度为 O(n) 的解法**，尝试使用更为精妙的**分治法**求解。

##### 2. 题解

###### (1) 动态规划

**dp 数组存放的是以当前索引位置结束的子数组中的最大子序列和**。首先对**数组进行遍历**，当前最大连续子序列**和为 sum**，结果为 ans。

- 如果 **sum > 0**，则说明 sum **对结果有增益效果**，则 **sum 保留并加上当前遍历数字**。
- 如果 **sum <= 0**，则说明 sum 对结果**无增益效果**，需要**舍弃**，则 sum 直接**更新为当前遍历数字**。

最后遍历 dp 数组找最大的值即可。

```java
public int maxSubArray(int[] nums) {
    // 数组长度
    int len = nums.length;
    if (len == 0) return 0;
    // 构造dp数组 dp数组存放的是以当前索引位置结束的子数组中的最大子序列和
    int[] dp = new int[len];
    // 初始化
    dp[0] = nums[0];
    // 遍历nums数组
    for (int i = 1; i < len; i++) {
        // 说明之前是正增益
        if (dp[i - 1] >= 0) {
            dp[i] = dp[i - 1] + nums[i];
        } else {
            // 直接取当前值
            dp[i] = nums[i];
        }
    }
    // 最后遍历dp数组找到子序列和最大值
    int res = dp[0];
    for (int i = 1; i < len; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

可以进一步**压缩空间**。**状态压缩** , 只需要一个变量 subMax 保存前面子组合的**最大值**，另外一个 max 保存**全局最大值**。其实代码结构差不多。

```java
public int maxSubArray2(int[] nums) {
    if (nums == null) return 0;
    // 全局最大值
    int maxSum = nums[0];
    // 前一个子组合的最大值,状态压缩
    int sum = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (sum > 0) {
            // 前一个子组合最大值大于0，正增益
            sum = sum + nums[i];
        } else {
            // 前一个子组合最大值小于0，抛弃前面的结果
            sum = nums[i];
        }
        // 计算全局最大值 滚动更新即可
        maxSum = Math.max(maxSum, sum);
    }
    return maxSum;
}
```

###### (2) 分治法

分治法是将整个**数组切分成几个小组**，然后每个小组再切分成几个**更小的小组**，一直到不能继续切分也就是**只剩一个数字**为止。每个小组会**计算出最优值**，汇报给**上一级的小组**，一级一级汇报，上级拿到下级的汇报找到最大值，得到最终的结果。和**归并排序**的算法类似，先切分，再合并结果。

这个问题中的关键就是**如何切分**这些组合才能使每个小组之间**不会有重复的组合**（有重复的组合意味着有重复的计算量）。首先是**切分分组方法**，就这个案例中的例子来，有一个数组 [-2, 1, -3, 4, -1, 2, 1, -5, 4] ，一共有 9 个元素，按照 center = (start + end) / 2 这个原则，得到中间元素的索引为 4 ，也就是 **-1**，拆分成**三个组合**：

- [-2, 1, -3, 4, -1] 以及它的**子序列**（在 -1 左边的并且包含它的为一组）。
- [2, 1, -5, 4] 以及它的子序列（在 -1 右边不包含它的为一组）。
- 任何包含 -1 以及它右边元素 2 的序列为一组（换言之就是**包含左边序列的最右边元素以及右边序列最左边元素的序列**，比如 [4, -1, 2, 1]，这样就保证这个组合里面的任何序列都不会和上面两个重复）。

以上的三个组合内的序列没有任何的重复的部分，而且一起构成所有子序列的全集，计算出这个三个子集合的最大值，然后取其中的最大值，就是这个问题的答案了。

然而前两个子组合可以用递归来解决，一个函数就搞定，第三个跨中心的组合应该怎么计算最大值呢？

答案就是先计算左边序列里面的包含最右边元素的子序列的最大值，也就是从左边序列的最右边元素向左一个一个累加起来，找出累加过程中每次累加的最大值，就是左边序列的最大值。

同理找出右边序列的最大值，就得到了右边子序列的最大值。左右两边的最大值相加，就是包含这两个元素的子序列的最大值。

在计算过程中，累加和比较的过程是关键操作，一个长度为 n 的数组在递归的每一层都会进行 n 次操作，分治法的递归层级在 logNlogN 级别，所以整体的时间复杂度是 O(nlogn)O(nlogn)，在时间效率上不如动态规划的 O(n)O(n) 复杂度。

分治法的思路是这样的，其实也是分类讨论。连续子序列的最大和主要由这三部分子区间里元素的最大和得到：

- 第 1 部分：子区间 [left, mid]；
- 第 2 部分：子区间 [mid + 1, right]；
- 第 3 部分：包含子区间[mid , mid + 1]的子区间，即 nums[mid] 与nums[mid + 1]一定会被选取。

对它们三者求最大值即可。

<img src="assets/image-20200518184713364.png" alt="image-20200518184713364" style="zoom:47%;" />

```java
public int maxSubArray3(int[] nums) {
    return maxSubArrayDivideWithBorder(nums, 0, nums.length - 1);
}

private int maxSubArrayDivideWithBorder(int[] nums, int start, int end) {
    // 只有一个元素，也就是递归的结束情况
    if (start == end) return nums[start];

    // 计算中间值
    int center = (start + end) / 2;
    // 分别递归计算左侧子序列最大值
    int leftMax = maxSubArrayDivideWithBorder(nums, start, center);
    int rightMax = maxSubArrayDivideWithBorder(nums, center + 1, end);
    // 下面计算横跨两个子序列的最大值
    // 计算包含左侧子序列最后一个元素的子序列最大值
    int leftCrossMax = Integer.MIN_VALUE; // 初始化一个值
    int leftCrossSum = 0;
    for (int i = center ; i >= start ; i --) {
        leftCrossSum += nums[i];
        leftCrossMax = Math.max(leftCrossSum, leftCrossMax);
    }

    // 计算包含右侧子序列最后一个元素的子序列最大值
    int rightCrossMax = nums[center+1];
    int rightCrossSum = 0;
    for (int i = center + 1; i <= end ; i ++) {
        rightCrossSum += nums[i];
        rightCrossMax = Math.max(rightCrossSum, rightCrossMax);
    }

    // 计算跨中心的子序列的最大值
    int crossMax = leftCrossMax + rightCrossMax;

    // 比较三者，返回最大值
    return Math.max(crossMax, Math.max(leftMax, rightMax));
}
```

#### 数组最长递增子序列【300.中等】

##### 1. 题目

给定一个无序的整数数组，找到其中最长上升子序列的长度。也就是 **Longest Increasing Subsequence (LIS)**。

```
输入: [10,9,2,5,3,7,101,18]
输出: 4  解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明**：可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。

**进阶**：你能将算法的时间复杂度降低到 O(n log n) 吗?

##### 2. 题解

###### (1) 动态规划

由于一个子序列一定会以一个数结尾，于是将状态定义成：**dp[i] 表示以 nums[i] 结尾的「上升子序列」的长度**。注意：这个定义中 nums[i] 必须被选取，且必须是这个子序列的最后一个元素。

遍历到 **nums[i]** 时，需要把下标 **i 之前**的所有的数都看一遍。只要 nums[i] 严格大于在它位置之前的**某个数**，那么 nums[i] 就可以接在这个数后面形成一个更长的上升子序列。

所以，**dp[i] 就等于下标 i 之前严格小于 nums[i] 的状态值的最大者 +1**。状态转移方程如下：

```java
dp[i] = max{1 + dp[j] for j < i if num[j] < num[i]}
```

![image-20200809163851242](assets/image-20200809163851242.png)

**也就是当前的 dp[i] 等于之前的所有小于 nums[i] 的位置中 dp 值最大的。**

```java
public int lengthOfLIS(int[] nums) {
    // Base case
    int len = nums.length;
    if (len == 0) return 0;

    int res = 1;
    int[] dp = new int[len];
    // 初始化dp，全部填充为1
    Arrays.fill(dp, 1);

    for (int i = 1; i < len; i++) {
        // 找到之前所有小于nums[i]的值中dp值最大的
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    // 找dp中最大的值
    for (int i = 0; i < len; i++) {
        res = Math.max(dp[i], res);
    }
    return res;
}
```

###### [(2) 动态规划+二分查找](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/)

以上解法的时间复杂度为 O(N<sup>2</sup>)，可以使用**二分查找**将时间复杂度降低为 O(**NlogN**)。

定义一个 **tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素**。对于一个元素 x，

- **如果它大于 tails 数组所有的值，那么把它添加到 tails 后面，表示最长递增子序列长度加 1**；
- **如果 tails[i - 1] < x <= tails[i]，那么更新 tails[i] = x**。

例如对于数组 [4, 3, 6, 5]，有：

```html
tails      len      num
[]         0        4
[4]        1        3
[3]        1        6
[3,6]      2        5
[3,5]      2        null
```

可以**看出 tails 数组保持有序**，因此在**查找 S<sub>i</sub> 位于 tails 数组的位置时就可以使用二分查找**。

```java
public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] tails = new int[n];
    int len = 0;
    for (int num : nums) {
        int index = binarySearch(tails, len, num);
        tails[index] = num;
        if (index == len) {
            len++;
        }
    }
    return len;
}

private int binarySearch(int[] tails, int len, int key) {
    int left = 0, right = len;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (tails[mid] == key) {
            return mid;
        } else if (tails[mid] > key) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

###### (3) 返回子序列 

这里思考一个问题：在上面的代码中只求**解出了上升子序列的长度**，那么如何求出具体的**上升子序列**呢？看代码！也就是首先按照上述的过程构造一个 dp 数组，数组中可能有多个最大值，也就是有多个最大上升子序列，此时找到全部的索引，然后从索引处，找到全部比他小的数字加入队列，**最后逆序队列即可**。

```java
public List<List<Integer>> lengthOfLIS3(int[] nums) {
    List<List<Integer>> resList = new ArrayList<>();
    int n = nums.length;
    if (n == 0) return null;

    int maxLength = 1;
    int[] dp = new int[n];
    // 初始化dp
    Arrays.fill(dp, 1);

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        // 每次更新最大的值
        maxLength = Math.max(maxLength, dp[i]);
    }

    // 记录一下有几个最长上升子序列及其位置
    List<Integer> lisIndex = new ArrayList<>();
    // 寻找所有最大上升子序列的结束位置
    for (int i = 0; i < n; i++) {
        if (dp[i] == maxLength) {
            lisIndex.add(i);
        }
    }

    for (int lastIndex : lisIndex) {
        ArrayList<Integer> list = new ArrayList<>();
        int nowMemoCount = dp[lastIndex];
        for (int i = lastIndex; i >= 0; i--) {
            if (nowMemoCount - dp[i] == 1 || nowMemoCount - dp[i] == 0) {
                list.add(nums[i]);
                nowMemoCount--;
            }
        }
        // 由于是从后往前加的结果，需要转换结果
        Collections.reverse(list);
        resList.add(list);
    }
    return resList;
}
```

#### 一组整数对能够构成的最长链【646.中等】

##### [1. 题目](https://leetcode-cn.com/problems/maximum-length-of-pair-chain)

给出 n 个数对。 在每一个数对中，**第一个数字总是比第二个数字小**。现在，我们定义一种跟随关系，当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来**构造一个数对链**。给定一个对数集合，找出能够形成的**最长数对链的长度**。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

```html
输入: [[1,2], [2,3], [3,4]]  
输出: 2  解释: 最长的数对链是 [1,2] -> [3,4]
```

##### 2. 题解

###### (1) 动态规划

**最长上升子序列**是一个很经典的算法题。有的会直接让你求最长上升子序列，有的则会换个说法，但最终考察的还是最长上升子序列，比如这里就是。**这个题的含义也是最长递增子序列**。

在一个长度为 k，以 pairs[i] 结尾的数对链中，**如果 pairs\[i][1] < pairs\[j][0]，则将该数对加入链中**，数对链长度**变为 k+1**。

根据数对的**第一个数排序**所有的数对，dp[i] 存储以 pairs[i] 结尾的最长链的长度。**当 i < j 且 pairs\[i][1] < pairs\[j][0] 时，扩展数**。

```java
public int findLongestChain(int[][] pairs) {
    if (pairs == null || pairs.length == 0) return 0;
    Arrays.sort(pairs, (a, b) -> (a[0] - b[0]));
    int len = pairs.length;
    int[] dp = new int[len];
    // 初始化dp数组
    Arrays.fill(dp, 1);
    for (int i = 1; i < len; i++) {
        for (int j = 0; j < i; j++) {
            // 转移方程
            if (pairs[j][1] < pairs[i][0]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    // 找到dp数组中的最大值
    int ans = 0;
    for (int x: dp) if (x > ans) ans = x;
    return ans;
}
```

###### (2) 贪心算法

使用贪心思想扩展数对链，在所有可作为下一个数对的集合中选择第二个数最小的数对添加到数对链。根据思路中的描述，按照数对**第二个数的升序序列遍历所有数对**，如果当前数对可以加入链，则加入。

```java
public int findLongestChain2(int[][] pairs) {
    Arrays.sort(pairs, (a, b) -> a[1] - b[1]);
    int cur = Integer.MIN_VALUE, ans = 0;
    for (int[] pair: pairs) if (cur < pair[0]) {
        cur = pair[1];
        ans++;
    }
    return ans;
}
```

#### 最长摆动子序列【376.中等】

##### [1. 题目](https://leetcode-cn.com/problems/wiggle-subsequence/)

如果**连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列**。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

```java
输入: [1,7,4,9,2,5] 输出: 6  解释: 整个序列均为摆动序列。
输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]
输入: [1,2,3,4,5,6,7,8,9] 输出: 2    
```

进阶：你能否用 O(n) 时间复杂度完成此题?

##### 2. 题解

###### (1) 动态规划

为了更好地理解这一方法，用两个数组来 dp ，分别记作 **up 和 down** 。每当选择一个元素作为摆动序列的一部分时，这个**元素要么是上升的，要么是下降**的，这取决于**前一个元素**的大小。**up[i] 存的是目前为止最长的以第 i 个元素结尾的上升摆动序列的长度。类似的， down[i] 记录的是目前为止最长的以第 i 个元素结尾的下降摆动序列的长度。**

每当找到将第 i 个元素作为上升摆动序列的尾部的时候就更新 up[i] 。现在我们考虑如何更新 up[i] ，我们需要考虑前面所有的降序结尾摆动序列，也就是找到 down[j] ，**满足 j < i 且 nums[i] > nums[j]** 。类似的， down[i] 也会被更新。

```java
public int wiggleMaxLength(int[] nums) {
    if (nums.length < 2) return nums.length;
    // 两个dp数组
    int[] up = new int[nums.length];
    int[] down = new int[nums.length];

    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                up[i] = Math.max(up[i], down[j] + 1);
            } else if (nums[i] < nums[j]) {
                down[i] = Math.max(down[i], up[j] + 1);
            }
        }
    }
    return 1 + Math.max(down[nums.length - 1], up[nums.length - 1]);
}
```

###### [(2) 优化动态规划](https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode/)

优化空间到 O(N)。

```java
public int wiggleMaxLength2(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int up = 1, down = 1;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1]) {
            up = down + 1;
        } else if (nums[i] < nums[i - 1]) {
            down = up + 1;
        }
    }
    return Math.max(up, down);
}
```

#### 最长公共子序列【1143.中等】

##### [1. 题目](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。

```java
输入：text1 = "abcde", text2 = "ace"  输出：3  解释：最长公共子序列是 "ace"，它的长度为 3
输入：text1 = "abc", text2 = "abc" 输出：3 解释：最长公共子序列是 "abc"，它的长度为 3。
输入：text1 = "abc", text2 = "def" 输出：0 解释：两个字符串没有公共子序列，返回 0。  
```

##### 2. 题解

###### [(1) 动态规划](https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-tu-wen-jie-xi-by-yijiaoqian/)

对于**两个字符串的动态规划**问题，套路是通用的。

比如说对于字符串 s1 和 s2，它们的长度分别是 **m、n**，一般来说都要构造一个这样的 DP 数组：

```java
int[][] dp = new int[m + 1][n + 1]
```

这里要加 1 使用来确保这个 index 是有效的，而当加 1 之后就不需要去判断只是让索引为 0 的行和列表示空串。

专门让**索引为 0 的行和列表示空串**，`dp[0][...]` 和 `dp[...][0]` 都应该初始化为 0，这就是base case。

对于 text1：abcde 和 text2：ace 两个字符串，我们定义两个指针进行遍历 i 和 j。

遍历 text1 长度为 m，定义指针 i，从 0～m。固定 i 指针（i == 1）位置，接下来开始遍历 text2 长度为 n，定义指针 j，从 0~n。

![image-20200810130606105](assets/image-20200810130606105.png)

第一次遍历 i = 1, j = 1，两个 a 相同所以 dp\[1][1] = 1。
第二次遍历 i = 1, j = 2，a 与 c 不等，也不能是 0，这里需转换成 a 与 ac 最长子序列，这里需要把之前的关系传递过来，所以 dp\[1][2] = 1。
第三次遍历 i = 1, j = 3，a 与 e 不相同，把之前的关系传递过来，所以 dp\[1][3] = 1。

text2：ace 已经走完来第一轮，接下来 text1：abcde 走到来 b 字符。

第四次遍历 i = 2, j = 1，就是需要比较 ab 与 a 的最长子串，把之前的关系传递过来，所以 dp\[2][1] = 1。

遍历两个串字符，当不同时需要考虑两层遍历前面的值（关系传递），也就是左边和上边的其中较大的值，当想相同时，需要考虑各自不包含当前字符串的子序列长度，再加上 1。

因此可以得出：现在对比的这**两个字符不相同的**，那么要取 text1 往前退一格或者 text2 往前退一格中两个的**最大值**：

```java
dp[i + 1][j + 1] = Math.max(dp[i + 1][j], dp[i][j + 1]);
```

对比的**两个字符相同**，去找它们**前面各退一格的值**加 1 即可：

```java
dp[i + 1][j + 1] = dp[i][j] + 1;
```

参考代码：

```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length(), n = text2.length();
    int[][] dp = new int[m + 1][n + 1];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 分别获取两个串的字符
            char c1 = text1.charAt(i), c2 = text2.charAt(j);
            if (c1 == c2) {
                // 去找它们前面各退一格的值加1即可
                dp[i + 1][j + 1] = dp[i][j] + 1;
            } else {
                // 要么是text1往前退一格，要么是text2往前退一格，两个的最大值
                dp[i + 1][j + 1] = Math.max(dp[i + 1][j], dp[i][j + 1]);
            }
        }
    }
    return dp[m][n];
}
```

#### 判断是否是字符串子序列【392.简单】

##### [1. 题目](https://leetcode-cn.com/problems/is-subsequence)

给定字符串 sub 和 origin ，**判断 sub  是否为 origin 的子序列**。你可以认为 sub  和 origin 中**仅包含英文小写字母**。字符串 origin 可能会很长（长度 ~= 500,000），而 sub  是个**短字符串**（长度 <=100）。

字符串的一个子序列是原始字符串**删除一些（也可以不删除）字符而不改变剩余字符相对位置**形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

```java
s = "abc", t = "ahbgdc"  返回 true.

s = "axc", t = "ahbgdc"  返回 false.
```

后续挑战：如果有**大量输入的 Sub**，称作 S1, S2, ... , Sk 其中 k >= 10 亿，你需要依次检查它们是否为 Origin 的子序列。在这种情况下，你会怎样改变代码？

##### 2. 题解

###### (1) 双指针法

如果仅仅是匹配一个较短字符串 **sub** ，对于 **sub** 中每一个`char` 都**优先匹配最开始**遇到的，直接扫描一遍 **origin** 即可。也就是维护**两个指针**。相同则两个指针都加，否则只移动一个指针。

```java
public boolean isSubsequence(String sub, String origin) {
    int subLen = sub.length(), originLen = origin.length();
    int subIndex = 0, oriIndex = 0;
    while (subIndex < subLen && oriIndex < originLen) {
        if (sub.charAt(subIndex) == origin.charAt(oriIndex)) {
            subIndex++;
        }
        oriIndex++;
    }
    return subIndex == subLen;
}
```

###### (2) 库函数法

一种**双百**的解法复杂度为 O(N)，记住**这种解法**。

从 sub 中**依次取出一个字符**，到 origin 中去**查找**，**记录第一次出现的位置**；sub 中取出下一个字符，**从上次出现位置的下一个**开始查找，直到 sub 中的字符**全部扫描**完成。

```java
public boolean isSubsequence2(String sub, String origin) {
    // Base case
    if (sub == null || origin == null) return true;
    int searchedIndex = 0, tempLocation = 0;
    for (int i = 0; i < sub.length(); i++) {
        // 利用库函数找到当前字符在origin字符串中第一次出现的索引
        tempLocation = origin.indexOf(sub.charAt(i), searchedIndex);
        // 库函数没找到直接返回
        if (tempLocation < 0) return false;
        // 更新已经找过的索引
        searchedIndex = tempLocation + 1;
    }
    return true;
}
```

###### (3) 动态规划

后序挑战，如果 Sub **数量极大**。

```java
public boolean isSubsequence3(String sub, String origin) {
    // 预处理,开头加一个空字符作为匹配入口
    origin = " " + origin;
    int len = origin.length();
    // 记录每个位置的下一个ch的位置
    int[][] dp = new int[len][26];
    for (char ch = 0; ch < 26; ch++) {
        int position = -1;
        // 从后往前记录dp
        for (int i = len - 1; i >= 0; i--) {
            dp[i][ch] = position;
            if (origin.charAt(i) == ch + 'a') {
                position = i;
            }
        }
    }
    // 匹配
    int i = 0;
    // 跳跃遍历
    for (char ch : sub.toCharArray()) {
        i = dp[i][ch - 'a'];
        if (i == -1) return false;
    }
    return true;
}
```

#### 字符串的最长回文子序列【516.中等】

##### [1. 题目](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

给定一个字符串 s，找到其中最长的回文子序列。可以假设 s 的最大长度为1000。**最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，"bbbb"可以是字符串"bbbab"的子序列但不是子串。**给定一个字符串 s，找到其中最长的回文子序列。可以假设 s 的最大长度为 1000。

```java
输入: "bbbab" 输出: 4 一个可能的最长回文子序列为 "bbbb"
输入: "cbbd" 输出: 2 一个可能的最长回文子序列为 "bb"
```

##### 2. 题解

###### (1) 动态规划法

**dp\[i][j] 表示 s 的第 i 个字符到第 j 个字符组成的子串中，最长的回文序列长度是多少。**

如果 s 的**第 i 个字符和第 j 个字符相同**的话，直接加 2：

```java
dp[i][j] = dp[i + 1][j - 1] + 2
```

如果 s 的**第 i 个字符和第 j 个字符不同**的话：

````java
dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
````

然后注意遍历顺序，**i 从最后一个字符开始往前遍历，j 从 i + 1 开始往后遍历**，这样可以保证每个子问题都已经算好了。

**初始化**：**dp\[i][i] = 1 单个字符的最长回文序列是 1**。

**结果**：**dp\[0][n - 1]**。

计算方向如下所示。

<img src="assets/image-20200708204345225.png" alt="image-20200708204345225" style="zoom:30%;" />

```java
public int longestPalindromeSubseq(String str) {
    int len = str.length();
    int[][] dp = new int[len][len];
    // 从后往前dp
    for (int i = len - 1; i >= 0; i--) {
        // 初始化dp
        dp[i][i] = 1;
        for (int j = i + 1; j < len; j++) {
            // 状态转移方程
            if (str.charAt(i) == str.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    // 整个s的最长回文子串长度
    return dp[0][len - 1];
}
```

#### 分割整数构成字母字符串【91.中等】

##### [1. 题目](https://leetcode-cn.com/problems/decode-ways/)

一条包含字母 A-Z 的消息通过以下方式进行了编码：给定一个只包含数字的非空字符串，请计算解码方法的总数。

```java
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

```java
输入: "12" 输出: 2 解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
输入: "226" 输出: 3 解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。    
```

##### 2. 题解

```java
public int numDecodings(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == '0' ? 0 : 1;
    for (int i = 2; i <= n; i++) {
        int one = Integer.valueOf(s.substring(i - 1, i));
        if (one != 0) {
            dp[i] += dp[i - 1];
        }
        if (s.charAt(i - 2) == '0') {
            continue;
        }
        int two = Integer.valueOf(s.substring(i - 2, i));
        if (two <= 26) {
            dp[i] += dp[i - 2];
        }
    }
    return dp[n];
}
```



### 待整理

递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。



### 背包问题

背包问题很经典，也有很多衍生问题，需要好好掌握。

#### 0-1背包问题

##### 1. 题目

有一个**容量为 N** 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：**体积 w 和价值 v**。

定义一个**二维数组 dp 存储最大价值**，其中 **dp\[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值**。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：

- 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，**dp\[i][j] = dp\[i-1][j]**。
- 第 i 件物品添加到背包中，**dp\[i][j] = dp\[i-1][j-w] + v**。

第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：

<img src="assets/1563524739603.png" alt="1563524739603" style="zoom:67%;" />

##### 2. 题解

###### (1) 动态规划

```java
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```

###### (2) 空间优化

在程序实现时可以对 **0-1 背包做优化**。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp\[i-1][j] 也可以表示 dp\[i][j]。此时，

<img src="assets/1563524755629.png" alt="1563524755629" style="zoom:67%;" />

**因为 dp[j-w] 表示 dp\[i-1][j-w]，因此不能先求 dp\[i][j-w]，以防将 dp\[i-1][j-w] 覆盖。也就是说要先计算 dp\[i][j] 再计算 dp\[i][j-w]，在程序实现时需要按倒序来循环求解。**

```java
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[] dp = new int[W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = W; j >= 1; j--) {
            if (j >= w) {
                dp[j] = Math.max(dp[j], dp[j - w] + v);
            }
        }
    }
    return dp[W];
}
```

##### 3. 无法使用贪心算法的解释

**0-1 背包问题无法使用贪心算法来求解**，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22.

| id   | w    | v    | v/w  |
| ---- | ---- | ---- | ---- |
| 0    | 1    | 6    | 6    |
| 1    | 2    | 10   | 5    |
| 2    | 3    | 12   | 4    |

##### 4. 背包问题变种

- **完全背包**：物品数量为无限个。

- **多重背包**：物品数量有限制。

- **多维费用背包**：物品不仅有重量，还有体积，同时考虑这两种限制。

- **其它**：物品之间相互约束或者依赖。

#### 划分数组为和相等的两部分【416.中等】

##### [1. 题目](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给定一个只包含正整数的非空数组。**是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。**

```java
输入: [1, 5, 11, 5]  输出: true  解释: 数组可以分割成 [1, 5, 5] 和 [11]
输入: [1, 2, 3, 5]  输出: false  解释: 数组不能分割成两个元素和相等的子集
```

##### 2. 题解

可以看成一个**背包大小为 sum/2 的 0-1 背包问题**。

一个**等价转换**：是否可以从这个数组中挑选出一些正整数，**使得这些数的和等于整个数组元素的和的一半**。前提条件是：数组的和一定得是偶数，即数组的和一定得被 2 整除，这一点是特判。

作为“0-1 背包问题”，它的特点是：“**每个数只能用一次**”。思路是：物品一个一个选，容量也一点一点放大考虑（这一点是“动态规划”的思想，特别重要）。

在实际生活中也是这样做的，一个一个尝试把候选物品放入“背包”，看什么时候能容纳的价值最大。

**具体做法是**：画一个 **len 行**，**target + 1 列**的表格。这里 **len 是物品的个数**，**target 是背包的容量**。len 行表示一个一个物品考虑，target + 1多出来的那 1 列，**表示背包容量从 0 开始**，很多时候需要考虑这个容量为 0 的数值。

状态定义：**dp\[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j**。

状态转移方程：很多时候，状态转移方程思考的角度是“分类讨论”，对于“0-1 背包问题”而言就是**“当前考虑到的数字选与不选”**。

- 不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp\[i][j] = true；
- 选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。

状态转移方程是：

```java
dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]
```

代码如下：

```java
public boolean canPartition(int[] nums) {
    int len = nums.length;
    if (len == 0) return false;

    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    // 如果是奇数就不符合要求
    if ((sum & 1) == 1) return false;
    int target = sum / 2;

    // 创建二维状态数组，行：物品索引，列：容量（包括 0）
    boolean[][] dp = new boolean[len][target + 1];

    // 先填表格第0行，第1个数只能让容积为它自己的背包恰好装满
    if (nums[0] <= target) dp[0][nums[0]] = true;

    // 再填表格后面几行
    for (int i = 1; i < len; i++) {
        for (int j = 0; j <= target; j++) {
            // 直接从上一行先把结果抄下来，然后再修正
            dp[i][j] = dp[i - 1][j];
            if (nums[i] == j) {
                dp[i][j] = true;
                continue;
            }
            if (nums[i] < j) {
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
            }
        }
    }
    return dp[len - 1][target];
}
```

优化空间如下：

```java
public boolean canPartition(int[] nums) {
    int sum = computeArraySum(nums);
    if (sum % 2 != 0) return false;
    int W = sum / 2;
    boolean[] dp = new boolean[W + 1];
    dp[0] = true;
    for (int num : nums) {                 // 0-1 背包一个物品只能用一次
        for (int i = W; i >= num; i--) {   // 从后往前，先计算 dp[i] 再计算 dp[i-num]
            dp[i] = dp[i] || dp[i - num];
        }
    }
    return dp[W];
}

private int computeArraySum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    return sum;
}
```

##### 改变一组数的正负号使得它们的和为一给定数

[494. Target Sum (Medium)](https://leetcode.com/problems/target-sum/description/)

```html
Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
```

该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。

可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：

```html
                  sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)
```

因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。

```java
public int findTargetSumWays(int[] nums, int S) {
    int sum = computeArraySum(nums);
    if (sum < S || (sum + S) % 2 == 1) {
        return 0;
    }
    int W = (sum + S) / 2;
    int[] dp = new int[W + 1];
    dp[0] = 1;
    for (int num : nums) {
        for (int i = W; i >= num; i--) {
            dp[i] = dp[i] + dp[i - num];
        }
    }
    return dp[W];
}

private int computeArraySum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    return sum;
}
```

DFS 解法：

```java
public int findTargetSumWays(int[] nums, int S) {
    return findTargetSumWays(nums, 0, S);
}

private int findTargetSumWays(int[] nums, int start, int S) {
    if (start == nums.length) {
        return S == 0 ? 1 : 0;
    }
    return findTargetSumWays(nums, start + 1, S + nums[start])
            + findTargetSumWays(nums, start + 1, S - nums[start]);
}
```

##### 01 字符构成最多的字符串

[474. Ones and Zeroes (Medium)](https://leetcode.com/problems/ones-and-zeroes/description/)

```html
Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: There are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are "10","0001","1","0"
```

这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。

```java
public int findMaxForm(String[] strs, int m, int n) {
    if (strs == null || strs.length == 0) {
        return 0;
    }
    int[][] dp = new int[m + 1][n + 1];
    for (String s : strs) {    // 每个字符串只能用一次
        int ones = 0, zeros = 0;
        for (char c : s.toCharArray()) {
            if (c == '0') {
                zeros++;
            } else {
                ones++;
            }
        }
        for (int i = m; i >= zeros; i--) {
            for (int j = n; j >= ones; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
            }
        }
    }
    return dp[m][n];
}
```

##### 找零钱的最少硬币数

[322. Coin Change (Medium)](https://leetcode.com/problems/coin-change/description/)

```html
Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.
```

题目描述：给一些面额的硬币，要求用这些硬币来组成给定面额的钱数，并且使得硬币数量最少。硬币可以重复使用。

- 物品：**硬币**
- 物品大小：**面额**
- 物品价值：**数量**

因为硬币可以重复使用，因此这是一个**完全背包问题**。完全背包只需要**将 0-1 背包中逆序遍历 dp 数组改为正序遍历即可**。

```java
public int coinChange(int[] coins, int amount) {
    if (amount == 0 || coins == null || coins.length == 0) {
        return 0;
    }
    int[] dp = new int[amount + 1];
    for (int coin : coins) {
        // 将逆序遍历改为正序遍历
        for (int i = coin; i <= amount; i++) { 
            if (i == coin) {
                dp[i] = 1;
            } else if (dp[i] == 0 && dp[i - coin] != 0) {
                dp[i] = dp[i - coin] + 1;
            } else if (dp[i - coin] != 0) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] == 0 ? -1 : dp[amount];
}
```

##### 找零钱的硬币数组合

[518\. Coin Change 2 (Medium)](https://leetcode.com/problems/coin-change-2/description/)

```text-html-basic
Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**完全背包问题**，使用 dp 记录**可达成目标的组合数目**。

```java
public int change(int amount, int[] coins) {
    if (amount == 0 || coins == null || coins.length == 0) {
        return 0;
    }
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] = dp[i] + dp[i - coin];
        }
    }
    return dp[amount];
}
```

##### 字符串按单词列表分割

[139. Word Break (Medium)](https://leetcode.com/problems/word-break/description/)

```html
s = "leetcode",
dict = ["leet", "code"].
Return true because "leetcode" can be segmented as "leet code".
```

dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。该问题涉及到字典中单词的使用顺序，因此可理解为涉及顺序的完全背包问题。

求解顺序的完全背包问题时，对物品的迭代应该放在最里层。

```java
public boolean wordBreak(String s, List<String> wordDict) {
    int n = s.length();
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    for (int i = 1; i <= n; i++) {
        for (String word : wordDict) {   // 对物品的迭代应该放在最里层
            int len = word.length();
            if (len <= i && word.equals(s.substring(i - len, i))) {
                dp[i] = dp[i] || dp[i - len];
            }
        }
    }
    return dp[n];
}
```

##### 组合总和

[377. Combination Sum IV (Medium)](https://leetcode.com/problems/combination-sum-iv/description/)

```html
nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
```

涉及顺序的完全背包。

```java
public int combinationSum4(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int[] maximum = new int[target + 1];
    maximum[0] = 1;
    Arrays.sort(nums);
    for (int i = 1; i <= target; i++) {
        for (int j = 0; j < nums.length && nums[j] <= i; j++) {
            maximum[i] += maximum[i - nums[j]];
        }
    }
    return maximum[target];
}
```

#### 股票交易

股票问题通用解法详解参考：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/

##### 需要冷却期的股票交易

[309. Best Time to Buy and Sell Stock with Cooldown(Medium)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

题目描述：交易之后需要有一天的冷却时间。

<img src="assets/1563524785398.png" alt="1563524785398" style="zoom:50%;" />

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int N = prices.length;
    int[] buy = new int[N];
    int[] s1 = new int[N];
    int[] sell = new int[N];
    int[] s2 = new int[N];
    s1[0] = buy[0] = -prices[0];
    sell[0] = s2[0] = 0;
    for (int i = 1; i < N; i++) {
        buy[i] = s2[i - 1] - prices[i];
        s1[i] = Math.max(buy[i - 1], s1[i - 1]);
        sell[i] = Math.max(buy[i - 1], s1[i - 1]) + prices[i];
        s2[i] = Math.max(s2[i - 1], sell[i - 1]);
    }
    return Math.max(sell[N - 1], s2[N - 1]);
}
```

##### 需要交易费用的股票交易

[714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

```html
Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1
Selling at prices[3] = 8
Buying at prices[4] = 4
Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

题目描述：每交易一次，都要支付一定的费用。

<img src="assets/1563524799933.png" alt="1563524799933" style="zoom:50%;" />

```java
public int maxProfit(int[] prices, int fee) {
    int N = prices.length;
    int[] buy = new int[N];
    int[] s1 = new int[N];
    int[] sell = new int[N];
    int[] s2 = new int[N];
    s1[0] = buy[0] = -prices[0];
    sell[0] = s2[0] = 0;
    for (int i = 1; i < N; i++) {
        buy[i] = Math.max(sell[i - 1], s2[i - 1]) - prices[i];
        s1[i] = Math.max(buy[i - 1], s1[i - 1]);
        sell[i] = Math.max(buy[i - 1], s1[i - 1]) - fee + prices[i];
        s2[i] = Math.max(s2[i - 1], sell[i - 1]);
    }
    return Math.max(sell[N - 1], s2[N - 1]);
}
```


##### 只能进行两次的股票交易

[123. Best Time to Buy and Sell Stock III (Hard)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/)

```java
public int maxProfit(int[] prices) {
    int firstBuy = Integer.MIN_VALUE, firstSell = 0;
    int secondBuy = Integer.MIN_VALUE, secondSell = 0;
    for (int curPrice : prices) {
        if (firstBuy < -curPrice) {
            firstBuy = -curPrice;
        }
        if (firstSell < firstBuy + curPrice) {
            firstSell = firstBuy + curPrice;
        }
        if (secondBuy < firstSell - curPrice) {
            secondBuy = firstSell - curPrice;
        }
        if (secondSell < secondBuy + curPrice) {
            secondSell = secondBuy + curPrice;
        }
    }
    return secondSell;
}
```

##### 只能进行k次的股票交易

[188. Best Time to Buy and Sell Stock IV (Hard)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/)

```java
public int maxProfit(int k, int[] prices) {
    int n = prices.length;
    if (k >= n / 2) {   // 这种情况下该问题退化为普通的股票交易问题
        int maxProfit = 0;
        for (int i = 1; i < n; i++) {
            if (prices[i] > prices[i - 1]) {
                maxProfit += prices[i] - prices[i - 1];
            }
        }
        return maxProfit;
    }
    int[][] maxProfit = new int[k + 1][n];
    for (int i = 1; i <= k; i++) {
        int localMax = maxProfit[i - 1][0] - prices[0];
        for (int j = 1; j < n; j++) {
            maxProfit[i][j] = Math.max(maxProfit[i][j - 1], prices[j] + localMax);
            localMax = Math.max(localMax, maxProfit[i - 1][j] - prices[j]);
        }
    }
    return maxProfit[k][n - 1];
}
```

#### 字符串编辑

##### 删除两个字符串的字符使它们相等

[583. Delete Operation for Two Strings (Medium)](https://leetcode.com/problems/delete-operation-for-two-strings/description/)

```html
Input: "sea", "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
```

可以转换为求两个字符串的最长公共子序列问题。

```java
public int minDistance(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
    }
    return m + n - 2 * dp[m][n];
}
```

##### 编辑距离

[72. Edit Distance (Hard)](https://leetcode.com/problems/edit-distance/description/)

```html
Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

题目描述：修改一个字符串成为另一个字符串，使得修改次数最少。一次修改操作包括：插入一个字符、删除一个字符、替换一个字符。

```java
public int minDistance(String word1, String word2) {
    if (word1 == null || word2 == null) {
        return 0;
    }
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        dp[i][0] = i;
    }
    for (int i = 1; i <= n; i++) {
        dp[0][i] = i;
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])) + 1;
            }
        }
    }
    return dp[m][n];
}
```

##### 复制粘贴字符

[650. 2 Keys Keyboard (Medium)](https://leetcode.com/problems/2-keys-keyboard/description/)

题目描述：最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴。

```
Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
```

```java
public int minSteps(int n) {
    if (n == 1) return 0;
    for (int i = 2; i <= Math.sqrt(n); i++) {
        if (n % i == 0) return i + minSteps(n / i);
    }
    return n;
}
```

```java
public int minSteps(int n) {
    int[] dp = new int[n + 1];
    int h = (int) Math.sqrt(n);
    for (int i = 2; i <= n; i++) {
        dp[i] = i;
        for (int j = 2; j <= h; j++) {
            if (i % j == 0) {
                dp[i] = dp[j] + dp[i / j];
                break;
            }
        }
    }
    return dp[n];
}
```

#### 2 机器人到达指定位置方法数

N个位置，1~N, N大于等于2，开始时机器人在其中的 M 位置，它可以向左或者右走。如果到了位置 1，下一步只能是位置 2；如果到了位置 N, 下一步只能是位置 N - 1 。机器人走 K 步，最终来到位置 P 的总方法一共有多少种？

##### ① 暴力递归方式

通过**尝试**的方式找到解决方法！

```java
// N : 位置为1 ~ N，固定参数
// cur : 当前在cur位置，可变参数
// rest : 还剩res步没有走，可变参数
// P : 最终目标位置是P，固定参数
// 该函数的含义：只能在1~N这些位置上移动，
// 当前在cur位置，走完rest步之后，停在P位置的方法数作为返回值返回
public static int walk(int N, int cur, int rest, int P) {
    // 如果没有剩余步数了，当前的cur位置就是最后的位置
    // 如果最后的位置停在P上，那么之前做的移动是有效的
    // 如果最后的位置没在P上，那么之前做的移动是无效的
    if (rest == 0) {
        return cur == P ? 1 : 0;
    }
    // 如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2
    // 后续的过程就是，来到2位置上，还剩rest-1步要走
    if (cur == 1) {
        return walk(N, 2, rest - 1, P);
    }
    // 如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1
    // 后续的过程就是，来到N-1位置上，还剩rest-1步要走
    if (cur == N) {
        return walk(N, N - 1, rest - 1, P);
    }
    // 如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以走向左，也可以走向右
    // 走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走
    // 走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走
    // 走向左、走向右是截然不同的方法，所以总方法数要都算上
    return walk(N, cur + 1, rest - 1, P) + walk(N, cur - 1, rest - 1, P);
}
```

暴力递归下时间复杂度，高度为 k 的二叉树的搜索过程。

上述机器人走路的过程其实可以映射成一颗二叉树的遍历，其中存在大量的重复过程。比如 f(5, 5) 表示当前在 5 还剩 5 步，它后面的数量与之前的状态无关。 

##### ② 缓存数组方式

以下使用**缓存数组**来减少重复过程的计算（**没有计算**的状态拿一个**特殊值**表示）。--- 记忆化搜索

```java
public static int walkWays2(int N, int E, int S, int K) {
	// 初始化一个二维数组来记录已经走过的状态
    int[][] dp = new int[K + 1][N + 1];
    // 将数组全部初始化为 -1 说明是还没有算过的
	for (int i = 0; i <= K; i++) {
		for (int j = 0; j <= N; j++) {
			dp[i][j] = -1;
		}
	}
    // 这次带上状态记录数组
	return f2(N, E, K, S, dp);
}
```

```java
public static int f2(int N, int E, int rest, int cur, int[][] dp) {    // 说明缓存记录中已经有了记录 直接查询返回    if (dp[rest][cur] != -1) {        return dp[rest][cur];    }    // 缓存记录没命中    if (rest == 0) {        // 返回之前记录状态信息到数组中        dp[rest][cur] = cur == E ? 1 : 0;        return dp[rest][cur];    }    // rest > 0 有路可以走    if (cur == 1) { // 1 -> 2        dp[rest][cur] = f1(N, E, rest - 1, 2);    } else if (cur == N) {        dp[rest][cur] = f1(N, E, rest - 1, N - 1);    } else {        dp[rest][cur] = f1(N, E, rest - 1, cur - 1) + f1(N, E, rest - 1, cur + 1);    }    return dp[rest][cur];}
```

##### ③ 严格表结构法

通过分析表的结构来找答案。

```java
public static int ways3(int N, int M, int K, int P) {
    // 参数无效直接返回0
    if (N < 2 || K < 1 || M < 1 || M > N || P < 1 || P > N) {
        return 0;
    }
    int[] dp = new int[N + 1];
    dp[P] = 1;
    for (int i = 1; i <= K; i++) {
        int leftUp = dp[1];// 左上角的值
        for (int j = 1; j <= N; j++) {
            // 直接根据三种情况的依赖关系进行填表
            int tmp = dp[j];
            if (j == 1) {
                dp[j] = dp[j + 1];
            } else if (j == N) {
                dp[j] = leftUp;
            } else {
                dp[j] = leftUp + dp[j + 1];
            }
            leftUp = tmp;
        }
    }
    return dp[M];
}
```

#### 3 换钱的最少张数

给定数组 arr, arr 中所有的值都为正数且不重复。每个值代表一中面值的货币，每种面值的货币可以使用**任意张**，再给定一个整数 aim 代表要找的钱数，求组成 aim 的最少货币数。

**思路**

如果 arr 的长度为 N, 则生成一个行数为 N , 列数为 aim + 1 的动态规划表 dp\[N][aim + 1], dp\[i][j] 的含义为: 在可以任意使用 arr[0...i] 货币的情况下，组成 j 所需的最小张数。

设: arr = [5, 2, 3, 1] aim = 5

1.dp\[0..N - 1][0] 的值表示找钱数为 0 时需要的最少张数，所以全设为 0。（矩阵的第一列）

```
　　　　　0 0 0 0 0 0

　　dp=　0 0 0 0 0 0

　　　　　0 0 0 0 0 0

　　　　　0 0 0 0 0 0　
```

2. dp\[0][0...aim] 的值表示只能使用 arr[0] 货币也就是 5 的情况下，找 0 , 1, 2, 3, 4, 5 的钱的情况下。其中无法找开的一律设为 32 位的最大值，记为 **max**.

　　　　　　0  max  max  max  max  1  

　　dp =　   0   

　　　　　    0

　　　　　　0

      　3. 剩下的位置依次**从左到右**，再**从上到下**计算。假设计算到 (i,j) 位置，dp\[i][j] 的值**可能**来自下面的情况:

- **完全不使用**当前货币 arr[i] 情况系的最少张数，即 **dp\[i-1][j] + 0** 的值；
- 只**使用一张**当前货币 arr[i] 的情况下的最少张数，即**dp\[i - 1][j - arr[i]] + 1**  其中 j - arr[i] 的值为使用了一张arr[i] 后，还需要凑多少钱。 i - 1 是指使用 arr[i] 之前的钱来兑换；
- 只使用**两张**当前货币 arr[i] 的情况下的最少张数，即 **dp\[i - 1][j - 2 * arr[i]] + 2**；
- 只使用**三张**当前货币 arr[i] 的情况下的最少张数，即 **dp\[i - 1][j - 3 * arr[i]] + 3**；
- ........

==**所有情况中，取最小的纸张数**==。所以:

dp\[i][j] = min{dp\[i - 1][j],  dp\[i - 1][j - k * arr[i]]} + k  ==>

dp\[i][j] = min{dp\[i - 1][j], min{dp\[i - 1][j - x * arr[i]] + x (x >= 1)}}  ==>

设 x - 1 = y  >= 0  ==> x = y + 1代入得

dp\[i][j] = min{dp\[i - 1][j], min{dp\[i - 1][j - arr[i] - y * arr[i] + y + 1 (y >= 0)}}

又因为m in{dp\[i - 1][j - arr[i] - y * arr[i] + y (y >= 0)] =>

dp\[i][j - arr[i]] 因为其中 dp\[i - 1][j - y * arr[i] + y] = dp\[i][j] 

 最终有:dp\[i][j] = min{dp\[i - 1][j], dp\[i][j - arr[i] + 1]} 如果 j - arr[i] < 0,即发生越界。

说明 arr[i] 太大了，用一张都会超出钱数j，所以令 dp\[i][j] = dp\[i - 1][j] 即可。　　　　

```
		0   max  max  max  max   1  

dp =　  0   max   1　 max　2　　1

		0　　max　 1　 1　　2　  1

		0　　1　　　1　 1　　2　　1
```

```java
package chapter_4.solution3;

public class Solution {

    public static void main(String[] args) {
        int[] arr = {5,2,3,1};
        int aim = 5;
        System.out.println(minConins1(arr, aim));
    }

    public static int minCoins1(int[] arr, int aim){
        if(arr == null || arr.length == 0 || aim < 0){
            return -1;
        }
        int[][] dp = new int[arr.length][aim+1];
        int max = Integer.MAX_VALUE;
        // 设置第一行
        for(int j = 1; j <= aim; j++){
            dp[0][j] = max;
            if(j - arr[0] >= 0 && dp[0][j - arr[0]] != max ){
                dp[0][j] = dp[0][j - arr[0]] + 1;
            }
        }
        int left = 0;
        for(int i=1; i < arr.length; i++){
            for(int j=1; j <=aim; j++){
				left = max;
                if(j-arr[i] >=0 && dp[i][j-arr[i]] != max){
                    left = dp[i][j-arr[i]] + 1;
                }
                dp[i][j] = Math.min(left, dp[i-1][j]);
            }
        }
        return dp[arr.length-1][aim] != max ? dp[arr.length-1][aim] : -1;
    }
}
```

#### 4 换钱的方法数

给定数组 arr，arr 中所有的值都为整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数 aim 代表要换的钱数，求换钱有多少种方法。

举例：
arr = [5, 10, 25, 1]， aim = 0
组成0元的方法有1种，就是所有面值的货币都不用。所以返回1。
arr = [5, 10, 25, 1] , aim = 15
组成15元的方法有6种，分别为3张5元、1张10元+1张5元、1张10元+5张1元、10张1元+1张5元、2张5元+5元一张和15元一张。所以返回6。
arr = [3, 5] , aim = 2
任何方法都无法组成2元。所以返回0。

##### ① 暴力递归法

这道题可以体现暴力递归、记忆搜索和动态规划之间的关系，并且还可以在动态规划的基础上再进行一次优化。
暴力递归的方法。如果 arr = [5, 10, 25, 1] , aim = 1000， 分析过程如下：

1. 用 0 张 5 元的货币，让 [10, 25, 1] 组成剩下的 1000， 最终方法数记为 res1。
2. 用 1 张 5 元的货币，让 [10, 25, 1] 组成剩下的 995， 最终方法数记为 res2。
3. 用 2 张 5 元的货币，让 [10, 25, 1] 组成剩下的 990，最终方法数记为 res3。
    ………
4. 用 200 张 5 元的货币，让 [10, 25, 1] 组成剩下的 0，最终方法数记为 res201。

那么 **res1 + res2 + … + res201** 的值就是总的方法数。根据如上的分析过程定义递归函数 process(arr, index, aim)，它的含义是如何用 arr[index…N - 1] 这些面值的钱组成 aim，返回**总**的方法数。

```java
// 换钱的方法数
public static int coins1(int[] arr, int aim){
    // 方法一：暴力递归，时间复杂度最差为O（aim^N）
    if(arr == null || arr.length == 0 || aim < 0){
        return 0;
    }
    return process1(arr, 0, aim);
}

private static int process1(int[] arr, int index, int aim) {
    // 方法数为0
    int res = 0;
    // 说明index到了钱币面值数组的末尾
    if(index == arr.length){ // 因递归中有index + 1,所以最大为arr.length
        // aim=0,只有一种方法，就是所有面值都不用 如果剩余的钱 aim 刚好为0，则认为找到一种方法
        res = aim == 0 ? 1 : 0;
    } else {
        for(int i = 0; arr[index] * i <= aim; i++){
            res += process1(arr, index + 1, aim - arr[index] * i);
            // 对于arr[5,10,25,1],aim=1000
            // 用0张5，让[5,10,25,1]组成剩下的1000，方法res1
            // 用1张5，让[5,10,25,1]组成剩下的995，方法res2
            // 用200张5，让[5,10,25,1]组成剩下的0，方法res201
            // res  =res1 + .... + res201
        }
    }
    return res;
}
```

上述的暴力递归存在大量的重复计算，可能造成栈溢出。当已经使用 0 张 5 元 + 1张 10 元的情况下，后续应该求[25, 1] 组成剩下的 990 的方法总数。当已经使用 2 张 5 元 + 0 张 10 元的情况下，后续还是求 [25, 1] 组成剩下的990 的方法总数。两种情况下都需要求 process(arr, 2, 990)。类似这样的**重复计算**在暴力递归的过程中大量产生，所以暴力递归方法的时间复杂度非常高，并且与 arr 中钱的面值有关，最差的情况下为 O(aim^N)。

##### ② 缓存数组法

进行一些优化处理，process(arr, index, aim) 中 arr 始终**不变**的，**变化的**只有 **index** 和 **aim**，所以可以用p(index, aim) 表示一个递归的过程。重复计算是因为没一个递归过程都没记下来，所以下次还要重复去求，所以可以事先准备好一个 **map**，**每计算完一个递归过程，都将结果记录到 map 中**。当下次进行同样的递归过程之前，先在 map 中查询这个递归过程是否已经计算过，如果已经计算过，就把值拿出来直接用，如果没有计算过，需要再进入递归过程。具体看下面的代码中的 coins2 方法，它和 coins1 方法的区别就是准备好**全局变量 map**，记录已经计算过的递归过程的结果，防止下次重复计算。因为本题的递归过程可由两个变量表示，所以map 是一张二维表。map\[i][j] 表示递归过程 p(i,j) 的返回值。另外还有一些特别值，map\[i][j] 表示递归过程 p(i,j) 从来没有计算过。map\[i][j] == -1表示递归过程 p(i,j) 计算过，但返回值是 0。如果 map\[i][j] 的值既不等于 0，也不等于 -1，记为 a，则表示递归过程 p(i, j) 的**返回值为 a**。

```java
// 获得换钱的方法数目(记忆搜索方法O(N*aim^2))
public static int getCoinNum02(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim <= 0) {
        return 0;
    }
    // 用于记录的memo map
    int[][] map = new int[arr.length + 1][aim + 1];
    return process02(arr, 0, aim, map);

}
// 使用记录数组的记忆化搜索
public static int process02(int[] arr, int index, int aim, int[][] map) {
    
    int res = 0;
    if (index == arr.length) {
        res = aim == 0 ? 1 : 0;
    } else {
        int mapValue = 0;
        for (int i = 0; arr[index] * i <= aim; i++) {
            
            // 对比记录已经计算过的值
            mapValue = map[index + 1][aim - arr[index] * i];
            if (mapValue != 0) {
                // 找到已经计算的结果
                res += mapValue == -1 ? 0 : mapValue;
            } else {
                res += process02(arr, index + 1, aim - arr[index] * i, map);
            }
        }
    }
    // 更新记录map的值
    map[index][aim] = res == 0 ? -1 : res;
    return res;
}
```

分析递归函数的状态可以由哪些变量表示，做出相应**维度**和大小的 map 即可。记忆化搜索方法的时间复杂度为**O(N * aim ^ 2)**。

##### ③ 动态规划法

```java
    //方法二：动态规划，非最优，时间复杂度为O（N×aim）
    public static int coins2(int[] arr, int aim) {
        if (arr == null || arr.length == 0 || aim < 0) {
            return 0;
        }
        int[][] dp = new int[arr.length][aim + 1];
        // dp[i][j]表示使用arr[0...i]组成j的方法数
        for (int i = 0; i < arr.length; i++) {
            dp[i][0] = 1;// 矩阵第一列，组成0的方法：1种
        }
        for (int j = 0; arr[0] * j <= aim; j++) {
            dp[0][arr[0] * j] = 1;//矩阵第一行，arr[0]组成arr[0]*j的方法：1种
        }
        // 求一般位置的dp[i][j],由两者叠加
        for (int i = 1; i < arr.length; i++) {
            for (int j = 1; j <= aim; j++) {
                dp[i][j] = dp[i - 1][j];// 不用arr[i]组成j
                dp[i][j] += j - arr[i] >= 0 ? dp[i][j - arr[i]] : 0;// 先用一张arr[i],剩下arr[0...i]组成j-arr[i]
            }
        }
        return dp[arr.length - 1][aim];// arr[0...N]组成aim的方法数
    }
```

还可以结合空间压缩写出更 NB 的动态规划。

#### 5 最长递增子序列

给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6， 7， 1， 2， 8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4.

① 先获取最长递增子序列的 dp 数组，d**p[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度**。
其值默认为 1，及当前位置的数是 num[0 - i] 中最大的数。dp[i] 为 dp[0...i - 1] 中最大的值 + 1。

② 根据获取的 dp 数字**反求**最长递增子序列。找到 dp 数组中最大的值 max 和位置，从右往左依次遍历，如果某个位置的 **dp[i] == max - 1 且 num[i] < num[max]**。则这个数可以定义为**倒数第二大**的数，依次类推。

注意：时间复杂度是 O(N^2)。因为求 dp 数组是 O(N^2)。可以使用一种二分查找的方式来将 dp 数组的生成复杂度降低到 O(NlogN)，也即整体的复杂度。

```java
// 生成dp数组
public int[] getDp(int[] array) {

    int[] dp = new int[array.length];
    for (int i = 0; i < dp.length; i++) {
        // 默认为1
        dp[i] = 1;
        // 当前的dp值跟之前的全部比他小的值得dp+1进行对比，选择最大的
        for (int j = 0; j < i; j++) {
            if (array[i] > array[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return dp;
}

/**
 * 根据dp数组和原数组找最长递增子序列
 */
public int[] generateLIS(int[] array, int[] dp) {
    // 最大递增序列长度
    int length = 0;
    // 最大dp值的索引，同时也是最长递增子序列的结尾值
    int index = 0;
    // 首先寻找上述两个值
    for (int i = 0; i < dp.length; i++) {
        if (dp[i] > length) {
            length = dp[i];
            index = i;
        }
    }
    int[] lis = new int[length];
    // 先把最后一个值填上
    lis[--length]  = array[index];
    for (int i = index; i >= 0; i--) {
        // 同时满足这两个条件才是前一个符合条件的数
        if (array[i] < array[index] && dp[index] == dp[i] + 1) {
            lis[--length] = array[i];
            index = i;
        }
    }
    return lis;
}
```

#### 6 最大公共子串

求两个字符串的最长公共子串。

再次辨析下两者的关系：

**最长公共子序列 VS 最长公共子串：**

**找两个字符串的最长公共子串，这个子串要求在原字符串中是连续的。而最长公共子序列则并不要求连续。**

其实最长公共子串的算法求解思想与最长公共子序列的思路基本类似。

DP 数组表示必须把 str1[i] 和 str2[j] 当做公共子串的最后一个字符的情况下最长公共子串的长度。

可以初始化第一行和第一列。相等为 1，不相等为 0。普通位置如果 str1[i] 和 str2[j] 两字符相同，则 dp\[i][j] 的值为左上角的值 + 1。

![image-20200324220026480](assets/image-20200324220026480.png)

```java
// 获取DP数组 DP数组表示必须把str1[i] str2[j]当做公共子串的最后一个字符的情况下最长公共子串的长度
public int[][] getDp(String string1, String string2) {

    char[] str1 = string1.toCharArray();
    char[] str2 = string2.toCharArray();

    // dp数组中的元素默认全部为0不用管
    int[][] dp = new int[str1.length][str2.length];
    // 根据base case初始化第一行
    for (int i = 0; i < str1.length; i++) {
        if (str1[i] == str2[0]) {
            dp[i][0] = 1;
        }
    }
    // 根据base case初始化第一列
    for (int i = 0; i < str2.length; i++) {
        if (str2[i] == str1[0]) {
            dp[0][i] = 1;
        }
    }
    // 从位置1开始，如果字符相等则最长的子串长度 + 1
    for (int i = 1; i < str1.length; i++) {
        for (int j = 1; j < str2.length; j++) {
            if (str1[i] == str2[j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
        }
    }
    return dp;
}
```

获取到 dp  数组之后，找到其中的最大值，然后倒推回去就找到最大公共子串了。

#### 7 最小编辑代价

给定两个字符串 str1 和 str2，再给定三个整数 ic，dc，rc，分别代表插入、删除、替换一个字符的代价，返回将str1 编辑成 str2 的最小代价。
举例：
str1="abc"   str2="adc"  ic=5    dc=3   rc=2，从"abc"编辑到"adc"把b替换成d代价最小，为2；
str1="abc"   str2="adc"  ic=5    dc=3   rc=10，从"abc"编辑到"adc"，先删除b再插入d代价最小，为8；

经典动态规划方法，利用二维数组 dp \[][] 保存动态规划表；
假设 str1 长度为 M[0.....M - 1]，str2 长度为 N[0.......N - 1]，dp 大小为 (M + 1) * (N + 1)；

dp\[i][j] 表示 str1[0......i - 1]编辑成 str2[0......j - 1]的最小编辑代价，dp 大小为(M + 1) * (N + 1)是为了从空串开始计算，即 dp\[0][0] 表示空串编辑到空串的最小编辑代价。


**如何生成 dp\[][]:**

1.dp\[0][0] 表示空串编辑成空串，故 dp\[0][0] = 0;

2.求第一行 dp\[0][j]，空串编辑成 str2[0....j - 1]，则 dp\[0][j] = ic * j;

3.求第一列 dp\[i][0]，str1[0......i - 1]编辑成空串，则dp\[i][0] = dc * i;

4.求dp\[i][j]，即 str1[0....i - 1]编辑成str2[0.....j - 1]，四种可能的途径：

- str1[0....i - 1] 先编辑成 str2[0.....j - 2]，再由 str2[0.....j - 2] 到 str2[0.....j - 1]，即 dp\[i][j - 1] + ic;

- str1[0....i - 1] 先编辑成 str1[0.....i - 2]，再由 str1[0.....i - 2]到 str2[0.....j - 1]，即 dc + dp\[i - 1][j];

- 如果 str1[i - 1] == str2[j - 1],则 dp\[i][j] = dp\[i - 1][j - 1];
- 如果 str1[i - 1] != str2[j - 1],则 dp\[i][j] = dp\[i - 1][j - 1] + rc;   

选择上面四个中**最小的值**作为 dp\[i][j]，时间复杂度 O(MN)，空间复杂度 O(MN)。最小编辑距离为 dp\[M][N]。

```java
public int findMinCost(String str1, String str2, int ic, int dc, int rc) {
    if (str1 == null || str2 == null) {
        return 0;
    }
    char[] chs1 = str1.toCharArray();
    char[] chs2 = str2.toCharArray();
    // dp数组长宽为字符串长度+1，因为需要考虑空串的情况
    int row = chs1.length + 1;
    int col = chs2.length + 1;
    int[][] dp = new int[row][col];
    // 初始化第一行和第一列
    for (int i = 1; i < row; i++) {
        dp[i][0] = dc + i;
    }
    for (int j = 1; j < col; j++) {
        dp[0][j] = ic * j;
    }
    // 四种普通情况取最小的
    for (int i = 1; i < row; i++) {
        for (int j = 1; j < col; j++) {
            if (chs1[i - 1] == chs2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = dp[i - 1][j - 1] + rc;
            }
            dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + ic);
            dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + dc);
        }
    }
    return dp[row - 1][col - 1];
}
```

#### 8 排成一条线的纸牌博弈问题

有一个整型数组 A，代表数值不同的纸牌排成一条线。玩家 a 和玩家 b 依次拿走每张纸牌，规定玩家 a 先拿，玩家 b 后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家 a 和玩家 b 都绝顶聪明，他们总会采用最优策略。请返回最后获胜者的分数。
给定纸牌序列  A 及序列的大小 n，请返回最后分数较高者得分数(相同则返回任意一个分数)。保证 A 中的元素均小于等于 1000。且 A 的大小小于等于300。
测试样例：
[1, 2, 100, 4], 4
返回：101

##### ① 暴力递归法

定义递归函数 **f(i, j)** ,表示如果 arr[i...j] 这个排列上的纸牌被绝顶聪明的人**先拿**，最终能够获得什么分数。
定义递归函数 **s(i,j)** ,表示如果 a[i..j] 这个排列上的纸牌被绝顶聪明的人**后拿**，最终能获得什么分数。
首先来分析 **f(i, j)**，具体过程如下：
1.如果 i == j (只有一张纸牌)，会被先拿纸牌的人拿走，所以返回 arr[i];
2.如果 i != j,先拿纸牌的人有**两种**选择，要么拿走 arr[i], 要么拿走 arr[j];
如果拿走 arr[i], 剩下 arr[i + 1, j]。对于 arr[i + 1, j] 的纸牌，当前玩家成了**后拿**的人，因此他后续能获得的分数为s(i + 1, j)。如果拿走 arr[j], 那么剩下 arr[i, j - 1],当前玩家后续能获得的分数为 s[i, j - 1],作为绝顶聪明的人，必然会在两种决策中选择**最优**的。所以返回 **max{arr[i] + s[i + 1, j], arr[j] + s\[i][j - 1]}**
然后来分析 **s(i, j)**:
1.如果 i == j, 后拿纸牌的人什么也拿不到，返回 0。
2.如果 i != j, 玩家的对手会先拿纸牌。对手要么先拿走 arr[i], 要么先拿走 arr[j], 如果对手拿走 arr[i], 那么排列剩下arr[i + 1, j], 如果对手拿走 arr[j], 剩下arr[i, j - 1]。对手也是绝顶聪明的人，所以也会把**最差**的情况留给玩家因此返回 **min{f(i + 1, j), f(i, j - 1)}**。

```java
// 暴力递归法
public int cardGame(int[] arr, int n) {
    if (arr == null || n == 0) {
        return 0;
    }
    return Math.max(f(arr, 0, n - 1), s(arr, 0, n - 1)); // write code here
}

// 先手拿取最大
public int f(int[] arr, int start, int end) {
    if (start == end) {
        return arr[start];
    }
    return Math.max(arr[start] + s(arr, start + 1, end), arr[end] + s(arr, start, end - 1));
}

// 后手拿取最小
public int s(int[] arr, int start, int end) {
    if (start == end) {
        return arr[start];
    }
    return Math.min(f(arr, start + 1, end), f(arr, start, end - 1));
}
```

##### ② 动态规划法

第一个玩家每次会保证自己是本次和另一个玩家取完最大值后再取剩下的的和最大 f\[i][j] 就记录最大值即

```java
Math.max(arr[j] + s[i][j - 1], arr[i] + s[i + 1][j]);
```

对于另一个玩家来说，会取第一个玩家取完剩下的较大的数，对于第一个玩家来说就是没取数之前较小的即

```java
Math.min(f[i + 1][j], f[i][j - 1]);
```

需要借助**两个** dp 数组。

```java
// 动态规划法
public int cardGameDp(int[] arr, int n) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    // 需要两个dp数组
    int[][] f = new int[n][n];
    int[][] s = new int[n][n];
    for (int j = 0; j < arr.length; j++) {
        f[j][j] = arr[j];
        for (int i = j - 1; i >= 0; i--) {
            // f[i][j]表示在arr[i...j]区间内当前玩家最大的累加和
            f[i][j] = Math.max(arr[j] + s[i][j - 1], arr[i] + s[i + 1][j]);
            // s[i][j]表示在arr[i..j]区间内的最小累加和
            s[i][j] = Math.min(f[i + 1][j], f[i][j - 1]);
        }
    }
    return Math.max(f[0][n - 1], s[0][n - 1]);
}
```



### 背包问题

有一个**容量为 C 的背包**，和一些物品。这些物品分别有两个属性，体积 w 和价值 v，每种物品只有一个。要求用这个背包装下价值尽可能多的物品，**求该最大价值**，背包可以不被装满。 

先得到该问题的**局部解然后扩展到全局问题解**。

可以假设一个B(k, C) 方法，第 k 件物品，当前背包所剩下的容量 C（初始则 C = W）情况下，能够偷的最大价值量。

```java
B( i , c ) = max{ F( i - 1 , C ) ,  v(i) + F( i - 1, C - w[i] ) };
```

##### (1) 记忆化搜索

```java
/**
 * 记忆化搜索
 * 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
 * 空间复杂度: O(n * C)
 */
public class Solution01 {
    private static int count = 0;
    private static int[][] memo;

    public int knapsack(int[] w, int[] v, int C) {
        int n = w.length;
        memo = new int[n][C + 1];
        for(int i = 0;i<n;i++)
            Arrays.fill(memo[i],-1);

        return bestValue(w, v, n - 1, C);
    }

    // 用 [0...index]的物品,填充容积为c的背包的最大价值
    private int bestValue(int[] w, int[] v, int i, int C) {
        count++;
        if (i < 0 || C <= 0)
            return 0;

        if (memo[i][C] != -1) // 记忆化搜索
            return memo[i][C];

        int res = 0;
        res = bestValue(w, v, i - 1, C);
        if (C >= w[i])
            res = max(res, v[i] + bestValue(w, v, i - 1, C - w[i]));

        return memo[i][C] = res;
    }

    private int max(int a, int b) {
        return a > b ? a : b;
    }

    public static void main(String[] args) {
        int[] w = {5,4,6,3};
        int[] v = {10,40,30,50};
        System.out.println(new Solution01().knapsack(w, v, 10));
        System.out.println("count of bestValue() exec：" + count);
        PrintHelper.print2DArray(memo);
    }
}
```

##### （2）动态规划

<img src="assets/image-20200602212425200.png" alt="image-20200602212425200" style="zoom: 62%;" />



```java
/**
 * 动态规划
 * 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
 * 空间复杂度: O(n * C)
 */
public class Solution02 {
    public int knapsack(int[] w, int[] v, int C) {
        int n = w.length;
        int[][] memo = new int[n][C + 1];

        if (n == 0 || C == 0)
            return 0;

        for (int j = 0; j <= C; j++)
            memo[0][j] = (j >= w[0] ? v[0] : 0);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= C; j++) {
                memo[i][j] = memo[i - 1][j];
                if (j >= w[i]) {
                    memo[i][j] = max(memo[i][j], v[i] + memo[i - 1][j - w[i]]);
                }
            }
        }

        return memo[n - 1][C];
    }

    private int max(int a, int b) {
        return a > b ? a : b;
    }


    public static void main(String[] args) {
        int[] w = {1, 2, 3};
        int[] v = {6, 10, 12};
        int C = 5;
        System.out.println(new Solution02().knapsack(w, v, C));
    }
}

```

##### （3）动态规划优化思路1

优化思路：第i行元素只依赖于第 i - 1 行元素，理论上，只需要保持两行元素即可

<img src="assets/image-20200602212523028.png" alt="image-20200602212523028" style="zoom: 33%;" />

```java
/// 动态规划改进: 滚动数组
/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
/// 空间复杂度: O(C), 实际使用了2*C的额外空间
public class Solution1 {

    public int knapsack01(int[] w, int[] v, int C){

        if(w == null || v == null || w.length != v.length)
            throw new IllegalArgumentException("Invalid w or v");

        if(C < 0)
            throw new IllegalArgumentException("C must be greater or equal to zero.");

        int n = w.length;
        if(n == 0 || C == 0)
            return 0;

        int[][] memo = new int[2][C + 1];

        for(int j = 0 ; j <= C ; j ++)
            memo[0][j] = (j >= w[0] ? v[0] : 0);

        for(int i = 1 ; i < n ; i ++)
            for(int j = 0 ; j <= C ; j ++){
                memo[i % 2][j] = memo[(i-1) % 2][j];
                if(j >= w[i])
                    memo[i % 2][j] = Math.max(memo[i % 2][j], v[i] + memo[(i-1) % 2][j - w[i]]);
            }

        return memo[(n-1) % 2][C];
    }
}
```

##### （4）动态规划优化思路2

<img src="assets/image-20200602212544715.png" alt="image-20200602212544715" style="zoom:50%;" />

```java
/// 动态规划改进
/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
/// 空间复杂度: O(C), 只使用了C的额外空间
public class Solution2 {

    public int knapsack01(int[] w, int[] v, int C){

        if(w == null || v == null || w.length != v.length)
            throw new IllegalArgumentException("Invalid w or v");

        if(C < 0)
            throw new IllegalArgumentException("C must be greater or equal to zero.");

        int n = w.length;
        if(n == 0 || C == 0)
            return 0;

        int[] memo = new int[C+1];

        for(int j = 0 ; j <= C ; j ++)
            memo[j] = (j >= w[0] ? v[0] : 0);

        for(int i = 1 ; i < n ; i ++)
            for(int j = C ; j >= w[i] ; j --)
                memo[j] = Math.max(memo[j], v[i] + memo[j - w[i]]);

        return memo[C];
    }
}
```

##### （5）背包问题更多变种

- **多重背包问题**：每个物品不不⽌1个，有 num(i) 个
- **完全背包问题**：每个物品可以⽆无限使⽤用
- **多维费用背包问题**：要考虑物品的体积和重量量两个维度？
- **物品间加入更更多约束**：物品间可以互相排斥；也可以互相依赖







