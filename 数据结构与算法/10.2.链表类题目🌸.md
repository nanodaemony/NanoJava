[TOC]

### 链表题目

#### 基础

##### 1.链表类问题解题技巧

###### (1)使用额外空间

使用**额外空间**(如 **HashMap、数组**)来辅助操作. 

场景: 复制链表的复制、判断链表是否有环等等. 

额外空间会增加空间复杂度, 而且很多题 O(1) 空间就行了, 不过使用额外空间在**笔试中**很不错.  

###### (2)引入dummy结点

对于**头结点可能会改变**的题目, 引入 dummy 结点是**基操**, 最后返回 dummy.next 即可. 

场景: 删除某个结点(可能把头结点删了), 两两一个交换结点(头结点会被交换出去)等. 

###### (3)快慢指针或双指针

由于链表无法直接寻址, 因此可以**引入多个指针**. **快慢指针**是非常巧妙且常见的技巧!

场景: 找链表中间结点、判断链表是否有环、删除倒数第 K 个结点、奇偶链表等. 

###### (4)牢记链表逆序的方法

很多题都需要**链表逆序**! 逆序可以使用**栈、递归、迭代**等方式实现. 栈比较费空间, 递归较难理解, 利用迭代可以通过画图的方式推出迭代路线. 

面试一定要掌握**迭代**的方式逆序. 

场景: 判断链表是否是回文结构(逆序后半部分)、两个链表数字相加(这个题用栈逆序贼方便, 看实际情况吧)、反转指定范围链表等. 

###### (5)学会画迭代思路图

不少题目使用额外空间很容易, 但是空间浪费, 但可以通过迭代的方式做出来, 因此**要学会分析题目画出迭代的关系, 指针的变化**步骤与方式. 

场景: 链表逆序(迭代方式)、两两一组交换链表、奇偶链表等. 

###### (6)其他

链表是**空节点**, 或者有一个值和一个指向下一个链表的指针, 因此很多链表问题可以用**递归**来处理. 

遇到需要**逆序**的情况, 如果不好处理, 可以考虑使用**栈**. 

**链表和树**的问题, 一般都可以有**递归和迭代**两种写法. 

##### 2.链表结点类

```java
public class ListNode {
    int val;
    ListNode next;
    
    ListNode() {}
    ListNode(int val) { this.val = val; }     
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```

##### 3.寻找链表中点

许多场景下可能需要寻找链表的中点, 或者需要找到后半部分链表的起点, 使用**快慢指针**的方式. 

代码如下: 

```java
ListNode fast = head;
ListNode slow = head;
while (fast.next != null && fast.next.next != null) {
    fast = fast.next.next;
    slow = slow.next;
}

// 第二部分的开头并断开两部分的指针
ListNode secondHead = slow.next;
slow.next = null;
```

这里 fast 和 slow **初始时都指向的是 head 节点**, 由于 fast 一次移动个节点, 所以需要判断 "fast.next.next != null", 移动完成后, "**slow.next**" 就是指向后半部分链表的开头. 

为什么 **slow.next** 一定是后半链表的开头? 这里需要分两种情况.

**结点数目为奇数**

这种情况下前面半条链表比后面半条链表**多一个节点**. fast 移动到最后一个节点就会停止, 此时 slow 到 4 的位置, **slow.next** 就是后半部分的开头.

![image-20220703160941311](assets/image-20220703160941311.png)

**结点数目为偶数**

这种情况下两条链表节点**数目一致**. fast 移动到倒数第二个节点就会停止, 此时 slow 到 3 的位置, **slow.next** 就是后半部分的开头.

<img src="assets/image-20220703161125338.png" alt="image-20220703161125338" style="zoom:57%;" />

### 反转链表类题目

这类题目涉及到反转整个链表或者部分链表. 

#### 反转单向链表[206.简单]

**题目描述**: https://leetcode-cn.com/problems/reverse-linked-list

反转一个单链表. 示例: 

```java
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**题解1: 迭代法**

<img src="assets/image-20220619204458870.png" alt="image-20220619204458870" style="zoom: 43%;" />

也叫**头插法**. 时间复杂度 **O(N), 空间复杂度 O(1)** 的算法. 引入 **dummy 结点**, 然后把**第一个结点**先弄好, 之后每次将新的结点插入到 dummy 结点的**后面一个**. 1.temp 结点指向 head; 2.head 后移; 3.temp 指向 dummy 的后一个结点; 4.dummy 指向 temp. 此时新的 temp 结点处理完成.

```java
public ListNode reverseList(ListNode head) {

    if (head == null || head.next == null) {
        return head;
    }

    ListNode dummy = new ListNode(0);

    while (head != null) {
        // 临时结点指向head
        ListNode temp = head;
        // head往后移动,此时temp指向的就是需要操作的结点
        head = head.next;
        // 将temp结点插入dummy后面
        temp.next = dummy.next;
        dummy.next = temp;
    }

    return dummy.next;
}
```

**题解2: 递归法**

Base case 就是已经处理到最后一个结点, 直接返回即可. 

![image-20220619211457272](assets/image-20220619211457272.png)

这里假设 head 指向 1, 此时 head.next 指向 2. 所以递归时需要传入 head.next 进行持续递归并使用 newHead 来表示已经递归好的结果. 这里即 reverseList() 方法已经将 2-3-4 完成逆序, 此时 newHead 指向 4. 然而由于此时 **head 依然 指向的是 head.next 也就是 1 指向 2**. 正确的逆序结果应该是 2 指向 1. 所以此时需要进行指针的变更: 即 head.next.next = head 使 2 指向 1, 且 head 指向 null 防止循环链表. 

```java
public ListNode reverseList(ListNode head) {

    // Base case: 已经到链表最后一个节点, 逆序就是自己
    if (head == null || head.next == null) {
        return head;
    }

    // 将head后面的链表逆序,假设返回的就是逆序后的结果
    ListNode newHead = reverseList(head.next);
    // 为了防止循环链表需要修改指针
    head.next.next = head;
    head.next = null;

    // 返回新的头结点
    return newHead;
}
```

#### 反转指定范围的链表[92.中等]

**题目描述**: https://leetcode-cn.com/problems/reverse-linked-list-ii

反转从**位置 m 到 n** 的链表. 请使用**一趟扫描**完成反转. 注意: 1 ≤ m ≤ n ≤ 链表长度. 

```java
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

**题解1: 迭代法**

将链表分为 3 个部分, 2 个**不反转**部分和 1 个**反转**的部分. 

- 前面的**不反转**部分, **保留最后一个节点**, 后面的不反转部分, 保留**第一个**节点. 
- 对于**反转**部分, 要**保留第一个端点**. 
- 反转结束后, 将三个部分**拼接**起来. 

![image-20220619221433793](assets/image-20220619221433793.png)

由于**反转**的可能涉及第一个结点的变动, 所以**引入 dummy 结点**. 同时引入一个 **cur** 指针, **从前往后**一直遍历. 

这里假设 start = 4,  end = 6. cur 指针需要移动 3 次到达不需要反转部分的末尾即 originEnd, **记录一下**. 其下一个结点就是需要反转部分的开始, 即 revStart, **记录一下**. 此时让 cur 再走 3 次, 到达需要反转部分的末尾, 此时其下一个结点即末尾无需反转的开始, **记录一下**. 同时这里将需反转部分与最后的部分的连接断开. 最后对中间部分进行反转, 然后依次进行拼接即可. 注意: 这里 revStart 反转后就成了反转部分的末尾, 因此直接与 lastStart 进行拼接即可. 

```java
public ListNode reverseBetween(ListNode head, int start, int end) {
    // 引入dummy与cur结点
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode cur = dummy;

    // 找第一部分不用变的末尾(start = 4, end = 6)
    for(int i = 0; i < start - 1; i++) {
        cur = cur.next;
    }
    // 记录第一部分不用变化的末尾节点
    ListNode originEnd = cur;

    // 记录需要反转部分的起始结点
    ListNode revStart = originEnd.next;
    // 移动到需要反转部分的末尾(end - start = 2)
    for(int j = 0; j <= end - start; j++) {
        cur = cur.next;
    }
    // 此时cur指向需要反转部分的末尾, 其后面一个结点即为后面不需要变得部分的头结点
    ListNode lastStart = cur.next;
    // 当前cur指向需要反转链表的最后一个节点, 此时断开指针
    cur.next = null;
    // 反转链表, 经过反转, revBegin已经指向了反转后链表的末尾
    originEnd.next = reverse(revStart);
    
    // 连接最后一段不需要变化的部分
    revStart.next = lastStart;

    return dummy.next;
}

// 递归反转链表
ListNode reverse(ListNode head) {
    if (head.next == null) {
        return head;
    }
    ListNode newHead = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

#### 两两交换链表中的节点[24.中等]

**题目描述**: https://leetcode-cn.com/problems/swap-nodes-in-pairs

给定一个链表, **两两交换**其中相邻的节点, 并返回交换后的链表. **不能**只是单纯的改变节点内部的值, 而是**需要实际的进行节点交换**. 

```
1->2->3->4 返回 2->1->4->3
```

**题解1: 双指针遍历法**

首先由于需要操作**头结点**, 因此引入一个 **dummy** 结点, 用于保存最后返回的头结点. 图示如下图. 

<img src="assets/image-20220620230811967.png" alt="image-20220620230811967" style="zoom:35%;" />

- 再引入一个 **cur 结点**, 后续 cur 作为 dummy 结点移动. 
- 后续的结点**两两一组进行交换**, 主要是注意指针的变换, 类似于普通的**变量交换**, 如上图的步骤 1-3.
- 每当两个结点的处理完成后, cur 指针往**后移动两步**, head 移动到 cur 的**后面**, 再次重复上述的交换动作. 直到 cur 的后面没有结点或者只有一个结点为止. 

```java
public ListNode swapPairs(ListNode head) {

    if (head == null || head.next == null) {
        return head;
    }

    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;

    while (head != null && head.next != null) {
        // 下面三步改变链表节点的指向
        cur.next = head.next;
        head.next = head.next.next;
        cur.next.next = head;

        // 移动指针
        head = head.next;
        cur = cur.next.next;
    }

    return dummy.next;
}
```

**题解2: 递归法**

递归牛逼. 

<img src="assets/image-20220620232934620.png" alt="image-20220620232934620" style="zoom:33%;" />

这里需要返回的新的头结点就是当前头结点的下一个结点, 所以 head.next 即 newHead, 这就是方法最终需要返回的对象. 由于一次处理两个结点, 所以假设两个结点之后的所有结点都已经完成处理, 此时让原始 head 指向"假设已经完成处理的链表". 最后新的头结点指向原始头结点完成交换并返回新的头节点即可. 

```java
public ListNode swapPairs(ListNode head) {

    // Base case
    if (head == null || head.next == null) {
        return head;
    }
    // 新的头结点就是当前头结点的下一个结点
    ListNode newHead = head.next;
    // 使当前头结点指向"假设已经完成处理的后续链表"
    head.next = swapPairs(head.next.next);
    // 新的头结点指向原始头结点完成交换, 并返回新的头结点
    newHead.next = head;
    return newHead;
}
```

#### K个一组翻转链表[25.困难]

**题目描述:** https://leetcode-cn.com/problems/reverse-nodes-in-k-group

给你一个链表, 每 **k 个节点一组**进行翻转, 返回翻转后的链表. k 是一个正整数, 且小于或等于链表的长度. 如果剩余节点总数**不是 k** 的整数倍, 那么将最后**剩余的节点保持原有顺序**. 

题目要求: 算法只能使用**常数**的额外空间. 不是仅交换数值, 需要**交换结点**. 

```java
链表: 1->2->3->4->5
当 k = 2 时, 应当返回: 2->1->4->3->5
当 k = 3 时, 应当返回: 3->2->1->4->5
```

**题解1: 快慢指针法**

题目要求算法只能使用**常数**的额外空间. 说明不能用递归, 只能用**迭代**的方式进行, 可以画个图理清每一个临界位置的指向. 

![image-20220621203440159](assets/image-20220621203440159.png)

- 引入 dummy 结点, 并初始化双指针 fast 和 slow. 然后进入死循环遍历. 
- 通过 k 次循环将 fast 指针移动到需要**反转部分的末尾**. 循环中就可能遇到空, 此时退出循环即可. 
- 此时判断一下如果翻转元素不到 k 个, 即 end == null, 说明**已经到达末尾**, 直接返回即可. 
- 然后需要定义 **remainHead** 指向后面**剩余未处理的头结点**, 定义 **revHead** 指向本轮**需要反转部分的头结点**, 以便将翻转元素前后两部分连接起来. 
- 断开需反转部分和剩余部分的指针, 并进行反转, 反转后将结果拼接到 slow 指针之后. 
- 最后重新建立连接, 并将快慢指针重置到当前的 revHead 处, 持续进行下一轮循环. 

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;

    // 快慢双指针
    ListNode fast = dummy;
    ListNode slow = dummy;

    while (true) {
        // fast遍历到需要翻转部分的最后一个元素位置
        for (int i = 0; i < k && fast != null; i++) {
            fast = fast.next;
        }
        // 说明fast到了链表尾部,此轮反转长度不够,直接跳出循环
        if (fast == null) {
            break;
        }
        // 记录剩余未处理链表的头结点
        ListNode remainHead = fast.next;
        // 定义start指向翻转元素的第一个位置
        ListNode revHead = slow.next;
        // 最后一个翻转元素先断链
        fast.next = null;
        // 然后通过翻转方法reverse()后接在slow后面
        slow.next = reverse(revHead);
        // 保持下次循环一致的位置
        revHead.next = remainHead;
        // 一轮反转后重置指针
        slow = revHead;
        fast = revHead;
    }

    return dummy.next;
}

// 递归反转链表
private ListNode reverse(ListNode head) {
    if (head.next == null) {
        return head;
    }
    ListNode newHead = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

### 链表合并与切分类题目

当需要变换链表时, 直接引入一个 dummy 结点, 然后把处理完成的链表弄到 dummy 后面即可. 

#### 合并两个有序的链表[21.简单]

**题目描述:** https://leetcode-cn.com/problems/merge-two-sorted-lists/

两个链表都是从小到大排列, 合并两个链表, 使其合并之后依然是从小到大排列. 

**题解1: 递归法**

**递归版本**, 额外空间为 **O(N)**. 关键点在于需要区分两种情况, 进行分别递归. 

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

    if (list1 == null || list2 == null) {
        return list1 != null ? list1 : list2;
    }

    // 到这里说明两个链表均不为空, 指定head
    ListNode head = null;

    // 这里分两种情况分别初始化head, 并将下一个结点设置为剩下的合并后的结果
    if (list1.val < list2.val) {
        head = list1;
        head.next = mergeTwoLists(list1.next, list2);
    } else {
        head = list2;
        head.next = mergeTwoLists(list1, list2.next);
    }
    return head;
}
```

**题解2: 迭代法**

需要找到**小的起始值**开始遍历合并, 完成处理后的结点依次连接到 dummy 结点后面形成一条新的链表. 

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

    if (list1 == null || list2 == null) {
        return list1 != null ? list1 : list2;
    }

    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;

    // 都不为空才遍历
    while (list1 != null && list2 != null) {
        // 分情况取两个链表的头结点
        if (list1.val < list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        // 移动cur指针到末尾并断开其对后面链表的连接
        cur = cur.next;
        cur.next = null;
    }

    // 到这里说明其中一个链表为null了 连接上后面的即可
    if (list1 == null) cur.next = list2;
    if (list2 == null) cur.next = list1;

    return dummy.next;
}
```

#### 合并K个有序链表[23.困难]

**题目描述:** https://leetcode-cn.com/problems/merge-k-sorted-lists

**合并 k** 个排序链表, 返回合并后的排序链表, 请分析和描述算法的复杂度. 

```
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

**题解1: 逐一比较**

比较 k 个节点(每个链表的首节点), 获得最小值的节点. 不断将节点接在最终有序链表的后面. 

**题解2: 使用优先队列**

几乎与上述方法一样, 除了将 **比较环节** 用 **优先队列** 进行了优化. 将**所有的数值放入到优先队列中, 再逐一出队列**. 

**题解3: 逐一两两合并链表**

利用合并两个链表的思想, **将合并 k 个链表的问题转化成合并 2 个链表 k-1 次**. 

**题解4: 分治法**

这个方法沿用了上面的解法, 但是进行了较大的优化. 不需要对大部分节点重复遍历多次. 如下图所示.

<img src="assets/image-20220622224516391.png" alt="image-20220622224516391" style="zoom:45%;" />

这里合并两条有序链表时采用了前述"合并两个有序的链表"的递归代码, 整体代码如下: 

```java
public ListNode mergeKLists(ListNode[] lists) {
    // Base case
    if (lists == null || lists.length == 0) {
        return null;
    }
    return merge(lists, 0, lists.length - 1);
}

private ListNode merge(ListNode[] lists, int left, int right) {
    if (left == right) {
        return lists[left];
    }

    int mid = left + (right - left) / 2;
    ListNode l1 = merge(lists, left, mid);
    ListNode l2 = merge(lists, mid + 1, right);

    // 递归合并两个列表
    return mergeTwoLists(l1, l2);
}

private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;

    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
```

#### 分隔链表[86.中等]

**题目描述: **https://leetcode-cn.com/problems/partition-list

给定一个**链表**和一个**特定值 x**, 对链表进行分隔, 使得所有**小于 x 的节点都在大于或等于 x 的节点之前**. 应当保留两个分区中每个节点的初始相对位置. 

<img src="assets/partition.jpg" alt="img" style="zoom:53%;" />

```
输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5
```

**题解1: 双指针法**

遍历链表, 根据值将链表拆分到两个链表中. 最后将链表进行拼接即可. 

- 引入两个 **dummy** 结点. 

- 不断**遍历**原链表, **小的结点挂载到小的链表, 大于等于的结点挂载到大的结点**. 

- 最后将**两个链表连接起来**. 整个过程没有新建结点, 额外空间是 O(1). 

```java
public ListNode partition(ListNode head, int x) {
    if (head == null || head.next == null) {
        return head;
    }

    // 拆成两条链表
    ListNode dummyLess = new ListNode(0);
    ListNode dummyMore = new ListNode(0);
    ListNode curLess = dummyLess;
    ListNode curMore = dummyMore;

    while (head != null) {
        // 分别往不同的链表追加
        if (head.val < x) {
            curLess.next = head;
            curLess = curLess.next;
        } else {
            curMore.next = head;
            curMore = curMore.next;
        }
        head = head.next;
    }
    // more后面的指针一定要断开 防止死循环
    curMore.next = null;
    // 链表拼接并返回
    curLess.next = dummyMore.next;
    return dummyLess.next;
}
```

#### 奇偶链表[328.中等]

**题目描述**: https://leetcode-cn.com/problems/odd-even-linked-list

给定一个单链表, 把所有的**奇数节点**和**偶数节点**分别**排在一起**. 这里的奇数节点和偶数节点指的是**节点编号**的奇偶性, 而**不是节点的值的奇偶性**. 

请尝试使用**原地算法**完成. 要求空间复杂度应为 **O(1)**, 时间复杂度为 O(N). 说明: 应当保持奇数节点和偶数节点的**相对顺序**. 链表的第一个节点视为奇数节点, 第二个节点视为偶数节点, 以此类推. 

```java
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```

**题解1: 双链表法**

与上个题类似, 只不过判断条件变化了, 引入两个 dummy 结点即可. 将奇节点拼接在一个链表里, 偶链表拼接在另一个链表里. 最后把偶链表接在奇链表的**尾部**. 

```java
public ListNode oddEvenList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    ListNode dummyOdd = new ListNode(0);
    ListNode dummyEven = new ListNode(0);
    ListNode curOdd = dummyOdd;
    ListNode curEven = dummyEven;

    int cnt = 1;
    while (head != null) {
        // 记录当前处理的临时结点
        ListNode temp = head;
        head = head.next;
        temp.next = null;
        // 分奇偶移动指针
        if (cnt++ % 2 == 1) {
            curOdd.next = temp;
            curOdd = curOdd.next;
        } else {
            curEven.next = temp;
            curEven = curEven.next;
        }
    }
    // 拼接奇偶情况
    curOdd.next = dummyEven.next;
    return dummyOdd.next;
}
```

**题解2: 双指针法**

解法与题解 1 类似, 只不过无需定义两个结点, 直接改变指针即可, 流程如下.

<img src="assets/image-20220701231837895.png" alt="image-20220701231837895" style="zoom:42%;" />

代码如下:

```java
public ListNode oddEvenList(ListNode head) {
    if (head == null) {
        return null;
    }

    // 第一个节点是奇结点(就是head), 第二个为偶结点的头结点, evenHead保存偶链表头部
    ListNode oddCur = head;
    ListNode evenCur = head.next;
    ListNode evenHead = evenCur;

    while (evenCur != null && evenCur.next != null) {
        // 奇结点的下一个是下一个偶结点的下一个
        oddCur.next = evenCur.next;
        // 往后移动奇结点指针
        oddCur = oddCur.next;
        // 偶结点的下一个是跳过一个位置的下一个
        evenCur.next = oddCur.next;
        // 往后移动偶结点指针
        evenCur = evenCur.next;
    }
    // 拼接两条链表
    oddCur.next = evenHead;
    // 返回头(就是奇结点头部)
    return head;
}
```

#### 链表分隔成K个链表[725.中等]

**题目描述: **https://leetcode-cn.com/problems/split-linked-list-in-parts

给定一个头结点为 root 的链表, 编写一个函数以将链表**分隔为 k 个连续**的部分. 每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1, 也就是说可能有些部分为 null. 这k个部分应该按照在链表中出现的顺序进行输出, 并且排在前面的部分的长度应该大于或等于后面的长度. 返回一个符合上述规则的链表的列表. 

```java
输入: root = [1, 2, 3], k = 5
输出: [[1],[2],[3],[],[]]
解释:输入输出各部分都应该是链表, 而不是数组. 

输入: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
解释:输入被分成了几个连续的部分, 并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度. 
```

**题解1: 迭代法**

![image-20220702112614959](assets/image-20220702112614959.png)

1. 先计算链表长度.
2. 计算出每条链表至少可以分 cutCnt 个节点, 由于存在可能不能刚好均分的情况, 所以需要计算一下前 moreCnt 条链表可以多分一个节点. 
3. 遍历构造 K 条链表, 注意前 moreCnt 条链表需要多分一个节点, 构造完成之后依次放到链表数组中即可. 

```java
public ListNode[] splitListToParts(ListNode root, int k) {
    ListNode head = root;
    // 求链表长度
    int length = 0;
    while (head != null) {
        head = head.next;
        length++;
    }

    // 计算每份至少多少个结点
    int cutCnt =  length / k;
    // 计算前面多少份需要多分一个(有可能不是恰好分完)
    int moreCnt = length % k;

    // 分别构造链表
    ListNode[] res = new ListNode[k];
    for (int i = 0; i < k; i++) {
        ListNode tempHead = new ListNode(0);
        ListNode cur = tempHead;
        // 判断如果prevCount > 0 , 则当前需要多分一份
        int curNum = moreCnt > 0 ? cutCnt + 1: cutCnt;
        moreCnt--;

        for (int j = 0; j < curNum; j++) {
            if (root != null) {
                cur.next = root;
                cur = root;
                root = root.next;
            }
        }

        // 切断前面的节点和后面的联系
        cur.next = null;
        res[i] = tempHead.next;
    }
    return res;
}
```

同样的思路另一种写法.

```java
public ListNode[] splitListToParts(ListNode head, int k) {
    ListNode cur = head;
    // 获取链表长度
    int length = 0;
    while (cur != null) {
        length++;
        cur = cur.next;
    }
    // 计算每份至少多少个结点
    int cutCnt = length / k;
    // 计算前面多少份需要多分一个(有可能不是恰好分完)
    int moreCnt = length % k;

    ListNode[] res = new ListNode[k];
    // 当前分配的链表条数
    int cnt = 0;
    while (head != null) {
        // curNum即当前的链表需要分配的结点数目(前面的几条链表需要多分配一个结点)
        int curNum = moreCnt > 0 ? (cutCnt + 1) : cutCnt;
        moreCnt--;

        // 构造链表
        ListNode tempHead = new ListNode(0);
        ListNode curNode = tempHead;
        while (curNum > 0) {
            curNode.next = head;
            head = head.next;
            curNode = curNode.next;
            curNum--;
        }
        // 与原本的链断开连接
        curNode.next = null;
        res[cnt] = tempHead.next;
        cnt++;
    }
    return res;
}
```

#### 重排链表[143.中等]

**题目描述: **https://leetcode-cn.com/problems/reorder-list

给定一个**单链表 L**: L0→L1→…→Ln-1→Ln, 将其重新排列后变为: L0→Ln→L1→Ln-1→L2→Ln-2→…

也就是**不断从链表两边取结点组合形成新的链表**. 不能只是单纯的改变节点内部的值, 而需要进行**节点交换**. 

```javascript
给定链表 1->2->3->4, 重新排列为 1->4->2->3.
给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.
```

**题解1: 逆转后半部分法**

利用由于是**一头一尾取元素**. 先利用**快慢指针找到链表的中间结点**. 将后半部分**链表逆序**(可以迭代或者递归逆序). 最后将前后**两个部分的链表交替连接合并起来即可**. 

![image-20220703163201191](assets/image-20220703163201191.png)

代码如下: 

```java
public void reorderList(ListNode head) {

    if (head == null || head.next == null || head.next.next == null) {
        return;
    }

    // 快慢指针将链表分半
    ListNode fast = head;
    ListNode slow = head;
    while (fast.next != null && fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }

    // 第二部分的开头并断开两部分的指针
    ListNode secondHead = slow.next;
    slow.next = null;

    // 逆序后半部分链表
    secondHead = reverse(secondHead);

    // 引入两个变量分别指向两个链表头部开始遍历
    ListNode firstCur = head;
    ListNode secondCur = secondHead;

    while (firstCur != null && secondCur != null) {
        // 分别记录两个temp结点并移动指针
        ListNode tempFirst = firstCur;
        ListNode tempSecond = secondCur;
        firstCur = firstCur.next;
        secondCur = secondCur.next;

        // 进行结点拼接
        tempFirst.next = tempSecond;
        tempSecond.next = firstCur;
    }
}

private ListNode reverse(ListNode head) {
    if (head.next == null) {
        return head;
    }
    ListNode newHead = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

#### 两个链表当成数字相加生成新链表[2.中等]

**题目描述:** https://leetcode-cn.com/problems/add-two-numbers

给出两个 **非空 的链表**用来表示两个**非负**的整数. 它们各自的位数是按照 **逆序 的方式存储**的, 并且它们的每个节点只能存储 一位 数字. 如果将这两个数相加起来, 则会返回一个新的链表来表示它们的和. 可以假设除了数字 0 之外, 这两个数都不会以 0 开头. 

```java
输入: (2 -> 4 -> 3) + (5 -> 6 -> 4)
输出: 7 -> 0 -> 8
原因: 342 + 465 = 807
```

**题解1: 直接相加法**

直接将两个链表**加起来**就行. 注意点: 可能其中一个链表已经是遍历完了, 还需要持续**遍历剩下**的; 还有可能存在结果进位的情况, 需要判断进位标志最后再处理一下.

两种情况:

**长度不够时补零**

![image-20220703173047841](assets/image-20220703173047841.png)

**最后有进位时需要处理**

![image-20220703173329158](assets/image-20220703173329158.png)

代码如下:

````java
public ListNode addTwoNumbers(ListNode list1, ListNode list2) {
    if (list1 == null|| list2 == null) {
        return list1 == null ? list2 : list1;
    }

    ListNode res = new ListNode(0);
    ListNode cur = res;

    // 记录进位
    int carry = 0;
    // 一直遍历直到两条链表都为空
    while (list1 != null || list2 != null) {

        // 小技巧: 当一条为空时值默认取0
        int num1 = list1 == null ? 0 : list1.val;
        int num2 = list2 == null ? 0 : list2.val;

        int sum = num1 + num2 + carry;
        // 刷新carry
        carry = sum / 10;
        // 记录当前加法值
        cur.next = new ListNode(sum % 10);

        if (list1 != null) list1 = list1.next;
        if (list2 != null) list2 = list2.next;

        cur = cur.next;
    }

    // 有可能存在结果进位的情况,需要判断进位标志最后再处理一下 如: 13+87=100
    if (carry > 0) {
        cur.next = new ListNode(carry);
    }
    return res.next;
}
````

也可以将 carry 整合到 while 条件里面:

```java
public ListNode addTwoNumbers(ListNode list1, ListNode list2) {
    if (list1 == null|| list2 == null) {
        return list1 == null ? list2 : list1;
    }

    ListNode res = new ListNode(0);
    ListNode cur = res;

    // 记录进位
    int carry = 0;
    // 一直遍历直到两条链表都为空且carry不为0
    while (list1 != null || list2 != null || carry > 0) {

        // 小技巧: 当一条为空时值默认取0
        int num1 = list1 == null ? 0 : list1.val;
        int num2 = list2 == null ? 0 : list2.val;

        int sum = num1 + num2 + carry;
        // 刷新carry
        carry = sum / 10;
        // 记录当前加法值
        cur.next = new ListNode(sum % 10);

        if (list1 != null) list1 = list1.next;
        if (list2 != null) list2 = list2.next;

        cur = cur.next;
    }

    return res.next;
}
```

#### 两个链表当成数字相加生成新链表II[445.中等]

**题目描述: **https://leetcode-cn.com/problems/add-two-numbers-ii

给你两个非空链表来代表两个非负整数. 数字最高位位于链表开始位置. 它们的每个节点只存储一位数字. 将这两数相加会返回一个新的链表. 你可以假设除了数字 0 之外, 这两个数字都不会以零开头. 

<img src="assets/1626420025-fZfzMX-image.png" alt="img" style="zoom:60%;" />

```java
输入: l1 = [7,2,4,3], l2 = [5,6,4]   输出: [7,8,0,7]
输入: l1 = [2,4,3], l2 = [5,6,4]     输出: [8,0,7]
输入: l1 = [0], l2 = [0]             输出: [0]
```

**题解1: 逆序法**

先将两个链表进行逆序, 然后参考上一题的思路进行处理, 最后把结果逆序. 

**题解2: 使用栈**

题目的进阶版是**不能修改原链表**. 然而需要实现逆序的操作, 此时可以考虑采用栈进行逆序. 此外, 每次处理一轮之后, 新生成的结点直接采用**头插法**进行链表构造就能省去最后链表逆序的操作. 采用栈之后的代码也很类似.

```java
public ListNode addTwoNumbers(ListNode list1, ListNode list2) {

    if (list1 == null || list2 == null) {
        return list1 == null ? list2 : list1;
    }

    // 使用栈使元素逆序 模拟逆序链表
    Stack<Integer> stack1 = new Stack<>();
    Stack<Integer> stack2 = new Stack<>();
    while (list1 != null) {
        stack1.push(list1.val);
        list1 = list1.next;
    }
    while (list2 != null) {
        stack2.push(list2.val);
        list2 = list2.next;
    }

    int carry = 0;
    ListNode res = new ListNode(0);
    ListNode cur = res;

    while (!stack1.isEmpty() || !stack2.isEmpty()) {
        int num1 = stack1.isEmpty() ? 0 : stack1.pop();
        int num2 = stack2.isEmpty() ? 0 : stack2.pop();
        int sum = num1 + num2 + carry;

        carry = sum / 10;

        // 直接采用头插法构造结果(最后就无需再次逆序结果)
        ListNode temp = new ListNode(sum % 10);
        temp.next = cur.next;
        cur.next = temp;
    }

    if (carry > 0) {
        ListNode temp = new ListNode(carry);
        temp.next = cur.next;
        cur.next = temp;
    }

    return res.next;
}
```

#### 循环向右旋转链表[61.中等]

**题目描述: **https://leetcode-cn.com/problems/rotate-list

给定一个链表, 旋转链表, 将链表每个节点向**右移动** k 个位置, 其中 k 是**非负数**. 

```java
输入: 1->2->3->4->5->NULL, k = 2     输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
```

```java
输入: 0->1->2->NULL, k = 4           输出: 2->0->1->NULL
解释:
向右旋转 1 步: 2->0->1->NULL
向右旋转 2 步: 1->2->0->NULL
向右旋转 3 步: 0->1->2->NULL
向右旋转 4 步: 2->0->1->NULL
```

**题解1: 快慢指针+连接成环法**

思路比较巧妙.

<img src="assets/image-20220705215355727.png" alt="image-20220705215355727" style="zoom:50%;" />

- 求出链表的**长度 length**. 
- 由于是循环移动, 所以 **k = k % length** 取模就是需要**右移的距离**. 
- 使用快慢指针, 其中快指针先走 k 步, 然后快慢指针一起移动直到快指针到末尾. 
- **连接成环**. 快指针连接上原来的头结点. 
- 断开环. 此时慢指针下一个结点即是新的头结点, 返回它即可. 不过这里需要断开慢指针与新头结点的指针. 

```java
public ListNode rotateRight(ListNode head, int k) {
    if (head == null || head.next == null) {
        return head;
    }

    int length = getLength(head);
    // 循环移动对长度取模即可
    k = k % length;

    // 慢指针初始指向头节点
    ListNode slow = head;
    // 快指针初始指向头节点
    ListNode fast = head;

    // 快指针先移动K步
    for(int i = 0; i < k; i++) {
        fast= fast.next;
    }

    // 快慢指针同时向前移动, 直到快指针指向链表末尾
    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }

    // 连接成环
    fast.next = head;
    // 新的头节点是慢指针所指节点的下一个节点
    head = slow.next;
    // 断开环
    slow.next = null;
    return head;
}

private int getLength(ListNode head){
    int len = 0;
    while (head != null) {
        head = head.next;
        len++;
    }
    return len;
}
```

### 删除结点类题目

#### 删除链表指定结点[237.简单]

**题目描述: **https://leetcode-cn.com/problems/delete-node-in-a-linked-list/

编写一个函数, 使其可以删除某个**链表中给定的(非末尾)节点**, 将只被给定要求被删除的节点. 

```java
public void deleteNode(ListNode node) {
	// Your Code
}
```

**题解**

注意: 此题**没有给头结点**, 比较特殊, **不能通过遍历**来找到需要删除的结点. 按照题目要求先**确保不是尾结点**, 然后用该结点的**下一个结点的==值覆盖==**掉要删除元素的值, 最后再**将重复元素断链**即删除了目标结点. 

<img src="assets/image-20220705220831457.png" alt="image-20220705220831457" style="zoom:40%;" />

代码如下:

```java
public void deleteNode(ListNode node) {

    if (node == null || node.next == null) {
        return;
    }
    // 用下一个结点的值替换当前结点值模拟删除
    node.val = node.next.val;
    // 修改指针
    node.next = node.next.next;
}
```

#### 删除链表中等于某个值的全部节点[203.简单]

**题目描述: **https://leetcode-cn.com/problems/remove-linked-list-elements/

删除链表中等于给定值 **val** 的所有节点. 

```txt
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

**题解1: 迭代法**

由于可能需要删除头结点, **引入 dummy 节点**. 整体流程就是直接遍历链表, 遇到与目标值不同的结点就拼接到 dummy 后面, 遇到要删除值的结点就直接跳过. 需要注意几种特殊情况, 一是**删除头结点**, 二是需要删除的节点连在一起, 三是删除末尾节点. 

```java
public ListNode removeElements(ListNode head, int val) {
    if(head == null) {
        return null;
    }

    // 可能删除头结点, 引入dummy节点
    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;

    while (head != null) {
        // 值不同的节点拼接到dummy后面
        if (head.val != val) {
            cur.next = head;
            head = head.next;
            cur = cur.next;
            cur.next = null;

            // 值相同直接跳过
        } else {
            head = head.next;
        }
    }
    return dummy.next;
}
```

**题解2: 递归法**

递归法比较巧妙, 主要根据当前链表的头结点是否需要删除而分为两种情况: 1.如果头结点需要删除, 则直接返回剩余链表的处理结果; 2.如果头结点无需删除, 则头结点保留, head.next 拼接后面剩余链表的删除结果. 

```java
public ListNode removeElements(ListNode head, int val) {

    // Base case
    if (head == null) {
        return null;
    }

    // 当头结点与目标值相同时, 舍弃头结点直接返回后面链表的处理结果
    if (head.val == val) {
        return removeElements(head.next, val);
    } else {
        // 头结点与目标值不同时, 头结点保留, head.next拼接后面剩余链表的删除结果即可 
        head.next = removeElements(head.next, val);
        // 返回头结点
        return head;
    }
}
```

#### 删除排序链表中的重复元素[83.简单]

**题目描述**: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list

给定一个**已经排序链表**, 删除**所有重复**的元素, 使得每个元素**只出现一次**. 

```java
输入: 1->1->2
输出: 1->2

输入: 1->1->2->3->3
输出: 1->2->3
```

**题解1: 迭代法**

已经排序说明相同的元素都是**挨在一起**的. 引入 dummy 节点, dummy 节点引导的链表就是删除后的链表. 遍历原链表, 依次判断原链表头结点是否与 dummy 链表尾结点相同, 不相同则添加到 dummy 链表末尾, 相同则移动忽略.  

<img src="assets/image-20220707221949811.png" alt="image-20220707221949811" style="zoom:40%;" />

由于是把节点挪到了新链表, 所以需要注意两链表直接的指针的断开. 

```java
public ListNode deleteDuplicates1(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    ListNode dummy = new ListNode(Integer.MAX_VALUE);
    ListNode cur = dummy;

    // 引入dummy节点, 如果
    while (head != null) {
        // 当前值与dummy链表尾部值不同 追加到dummy链表末尾
        if (head.val != cur.val) {
            cur.next = head;
            cur = cur.next;
            head = head.next;
            // 断开指针
            cur.next = null;
        } else {
            head = head.next;
        }
    }

    return dummy.next;
}
```

**题解2: 直接迭代法**

这里头结点是肯定保留的, 所以**不用 dummy 结点**. 直接**迭代遍历**, 对比**当前值和下一个结点**的值, 如果**相同则跳过下一个结点**, 如果不同则移动当前节点到下一个. 

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode cur = head;
    while(cur != null && cur.next != null) {
        // 结点值相同则删除重复结点(此时不移动cur指针)
        if(cur.val == cur.next.val) {
            cur.next = cur.next.next;
        } else {
            // 结点值不同则直接cur后移一个结点
            cur = cur.next;
        }
    }
    return head;
}
```

#### 删除排序链表中的重复元素II[82.中等]

**题目描述:** https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii

给定一个**排序链表**, 删除所有含有**重复数字**的节点, 只保留原始链表中 **没有重复出现** 的数字. 

```java
输入: 1->2->3->3->4->4->5
输出: 1->2->5

输入: 1->1->1->2->3
输出: 2->3
```

**题解1: 递归法**

Base case: 如果 head 为空, 或者只有一个结点时直接返回 head. 

其余情况分两种: 

如果 head.val != head.next.val, 说明头节点的值不等于下一个节点的值, 所以当前 head 节点须保留; 但并不知道 head.next 节点要不要保留, 因此需要对 head.next 进行递归, 即对剩下的 head.next 作为头节点的链表递归去除值重复的节点. 

如果 head.val == head.next.val, 说明头节点的值等于下一个节点的值, 所以当前的 head 节点必须删除, 并且 head 之后所有与 head.val 相等的节点也都需要删除; 删除到哪个节点为止? 需要用 cur 指针一直向后遍历寻找到与 head.val 不等的节点. 此时 cur 之前的节点都不保留了, 因此返回 deleteDuplicates(cur).

<img src="assets/image-20220708230258756.png" alt="image-20220708230258756" style="zoom:50%;" />

代码如下:

```java
public ListNode deleteDuplicates(ListNode head) {
    // Base case
    if (head == null || head.next == null) {
        return head;
    }

    // 当前节点和下一个节点的值不同, 则head的值是需要保留的, 对head.next继续递归
    if (head.val != head.next.val) {
        head.next = deleteDuplicates(head.next);
        return head;
    } else {
        // 当前节点与下一个节点的值重复了, 重复的值都不能要
        // 一直往下找, 找到不重复的节点. 返回对不重复节点的递归结果
        ListNode cur = head.next.next;
        while (cur != null && cur.val == head.val) {
            cur = cur.next;
        }
        return deleteDuplicates(cur);
    }
}
```

**题解2: 迭代法**

迭代**滑动窗口**解决. 头结点可能被删, 引入结点 **dummy**. 创建 **cur** 指针指向链表的**头部**. 接着对 cur 指针**迭代**, 对比 cur 指针的**下一个结点与下下一个结点的值**是否相等. 迭代过程中, 如果 **cur.next.val == cur.next.next.val** 说明此时**有重复元素**, 此时创建一个**临时指针 temp**, 指向 cur 的**下一个节点**, 即 temp 指向**第一个重复元素**所在的位置. 通过 while 循环**去重**, 去重后 temp 指向的是**重复元素中的最后一个位置**. 最后 cur.next = temp.next 即可**消除**重复中间的元素. 

<img src="assets/image-20220708231942538.png" alt="image-20220708231942538" style="zoom:43%;" />

代码如下:

```java
public ListNode deleteDuplicates(ListNode head) {
    // 可能要删掉头结点-引入dummy结点
    ListNode dummy = new ListNode(Integer.MAX_VALUE);
    dummy.next = head;

    ListNode cur = dummy;

    while (cur.next != null && cur.next.next != null) {
        // 说明此时后面的结点有重复
        if (cur.next.val == cur.next.next.val) {
            // 来一个临时节点指向重复区间的第一个结点
            ListNode temp = cur.next;
            // 循环去重 直到temp指向重复区间的最后一个结点
            while (temp.next != null && temp.val == temp.next.val) {
                temp = temp.next;
            }

            // 直接删掉重复的部分
            cur.next = temp.next;

            // 没有重复则移动指针
        } else {
            cur = cur.next;
        }
    }
    return dummy.next;
}
```

#### 删除链表倒数第n个结点[19.中等]

**题目描述:** https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list

给定一个链表, 删除链表的**倒数第 n 个**节点, 并且返回链表的**头结点**. 

```
链表: 1->2->3->4->5, n = 2. 当删除了倒数第二个节点后, 链表变为 1->2->3->5.
```

说明: 给定的 n 保证是**有效**的. 进阶: 尝试使用**一趟扫描**实现.

**题解1: 两次遍历法**

**删除倒数第 n 个结点**, 也就是删除从列表开头数起的第 **(L - n + 1)**个结点, 其中 L 是列表的**长度**. 代码不写了.

**题解2: 双指针单次遍历法**

可以优化为只使用**一次遍历**. 由于第一个结点可能被删除, 所以引入 dummy 节点. 使用**快慢双指针**. 快指针先移动 n 步, 然后快慢指针一起移动, 直到快指针移动到链表末尾最后一个节点, 此时慢指针的下一个节点就是倒数第 n 个结点. 

<img src="assets/image-20220709224234944.png" alt="image-20220709224234944" style="zoom:40%;" />

不需要去记移动几个, 画个图示意一下即可. 

```java
public ListNode removeNthFromEnd2(ListNode head, int n) {
    // 引入Dummy结点
    ListNode dummy = new ListNode(Integer.MAX_VALUE);
    dummy.next = head;

    ListNode fast = dummy, slow = dummy;

    // fast指针先走n步
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }
    // 当fast指针到达链表尾部停止
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    // 此时slow指针的下一个结点即需要删除的结点
    slow.next = slow.next.next;

    return dummy.next;
}
```

### 链表相交与环类问题

#### 判断链表是否有环[141.简单]

**题目描述:** https://leetcode-cn.com/problems/linked-list-cycle/

给定一个链表, 判断链表中**是否有环**. 

<img src="assets/circularlinkedlist.png" alt="img" style="zoom: 52%;" />

**题解1: 快慢双指针法**

使用快慢指针. 通过使用具有 **不同速度** 的快、慢两个指针遍历链表. **慢指针每次移动一步, 而快指针每次移动两步. **如果存在环则迟早会相遇. 

<img src="assets/d1ac82780e5189d7d58406504c3b7b56c35165997bfbb4c325677af92ee2d483-3855408.gif" alt="快慢指针在环上追及" style="zoom:67%;" />

```java
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }

    ListNode fast = head;
    ListNode slow = head;

    // 快指针没有移动到链表末尾则持续移动
    while (fast != null && fast.next != null) {
        // 快指针移动两步,慢指针移动一步
        fast = fast.next.next;
        slow = slow.next;
        // 快慢指针相遇
        if (fast == slow) {
            return true;
        }
    }
    return false;
}
```

写法2:

```java
public boolean hasCycle(ListNode head) {
    // Base case
    if (head == null || head.next == null) {
        return false;
    }
    // 初始化时快指针在慢指针之前一步
    ListNode slow = head;
    ListNode fast = head.next;
    // 一直判断指针是否相遇
    while (slow != fast) {
        // 并判断是否已经到头
        if (fast == null || fast.next == null) {
            return false;
        }
        // 否则分别移动两个指针
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}
```

#### 判断链表是否有环并返回第一个入环结点[142.中等]

**题目描述:** https://leetcode-cn.com/problems/linked-list-cycle-ii

给定一个链表, 返回链表开始入环的第一个节点.  如果链表无环, 则返回 null. 说明: 不允许修改给定的链表. 

<img src="assets/image-20200705133859192.png" alt="image-20200705133859192" style="zoom:50%;" />

**题解1: 快慢双指针法**

采用**"快慢指针"**的方法. 两个指针 fast 和 slow, 开始时两个指针都指向链表头 head, 然后在每一步操作中 slow 向前走一步而 fast 每一步向前两步. 

由于 fast 要比 slow 移动的快, 如果有环, fast 一定会先进入环, 而 slow 后进入环. 当两个指针都进入环之后, 经过一定操作后二者一定能够在环上相遇, 并且此时 slow 还没有绕环一圈, 也就是说一定是在 slow 走完第一圈之前相遇. 可以看下图: 

<img src="assets/image-20200321100046302.png" alt="image-20200321100046302" style="zoom:60%;" />

相遇后 **fast 指针回到头部**, **slow 指针不动**. 然后两者一起再次移动, 两个都一次**移动一步**, 直到相遇. 相遇的地方即入环的第一个结点.

证明过程如下: 

<img src="assets/image-20200807220009353.png" alt="image-20200807220009353" style="zoom:40%;" />

计算式如下: 

```
F + a + b + a = 2(F + a)  // 快指针移动距离为慢指针2倍
F + 2a + b = 2F + 2a
F = b	// 最后快慢指针一起移动即可以相遇
```

注意编码. 

```java
public ListNode detectCycle(ListNode head) {
    // 快慢指针
    ListNode fast = head;
    ListNode slow = head;

    while (true) {
        // 说明不存在环
        if (fast == null || fast.next == null) {
            return null;
        }

        fast = fast.next.next;
        slow = slow.next;

        // 快慢指针相遇退出循环
        if (fast == slow) {
            break;
        }
    }
    // 快指针回到head结点
    fast = head;
    // 快慢指针同时移动一步直到相遇的点
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }

    return fast;
}
```

#### 判断两个无环链表是否相交

**题目描述**

判断两个链表是否存在**交点**. 

**题解**

- **直接比较**两个链表的**最后一个节点是否相同**. 

- 把第一个链表的结尾连接到第二个链表的**开头**, 看第二个链表**是否存在环**.

#### 找两个无环链表的第一个相交结点[160.简单]

**题目描述:** https://leetcode-cn.com/problems/intersection-of-two-linked-lists/

判断两个**无环**的链表是否相交并得到**第一个相交**的结点. 不相交就返回 null. 

**题解1: 双指针法**

如果两个无环链表相交, 那么从**相交节点开始**, 一直到两个链表终止的这段, **二者共享**. 

- 使用两个指针分别统计两条链表的**长度**. 并分别移动到两条链表的**末尾结点**. 
- 对比两个末尾结点, 如果不相等则肯定没有相交. 
- 重新将两个指针分别指向链表开头. 计算链表长度的差值 **gap**, 让长的一条链表先移动 gap. 
- 最后两个指针一起移动, 直到指针**相遇**即为第一个相交结点. 

```java
public static ListNode getIntersectionNode(ListNode head1, ListNode head2) {
    if (head1 == null || head2 == null) {
        return null;
    }
    // 计算两个链表的长度 并让cur1和cur2各自到链尾部
    int len1 = 0, len2 = 0;
    ListNode cur1 = head1;
    ListNode cur2 = head2;

    while (cur1.next != null) {
        cur1 = cur1.next;
        len1++;
    }
    while (cur2.next != null) {
        cur2 = cur2.next;
        len2++;
    }
    // 链表尾部的两个结点不相同则肯定不相交
    if (cur1 != cur2) {
        return null;
    }

    // 编码技巧: 让cur1始终指向较长的一根链表 cur2指向较短的链表
    cur1 = (len1 > len2) ? head1 : head2;
    cur2 = (cur1 == head1) ? head2 : head1;
    // 求两个链表的长度差
    int gap = Math.abs(len1 - len2);
    // 链表长的先走gap步
    while (gap != 0 && cur1 != null) {
        cur1 = cur1.next;
        gap--;
    }

    // 两个链表同时运动找第一个相同的点
    while (cur1 != cur2) {
        cur1 = cur1.next;
        cur2 = cur2.next;
    }

    return cur1;
}
```

**再来一种写法. **

设 A 的长度为 a + c, B 的长度为 b + c, 其中 c 为尾部**公共部分长度**, 可知 a + c + b = b + c + a. 

当访问 A 链表的指针访问到**链表尾部时**, 令它从链表 B 的头部开始访问链表 B; 同样地, 当访问 B 链表的指针访问到链表尾部时, 令它从链表 A 的头部开始访问链表 A. **这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点**. 

如果**不存在交点**, 那么 a + b = b + a, 以下实现代码中 l1 和 l2 **会同时为 null**, 从而**退出**循环. 

```java
public ListNode getIntersectionNode(ListNode head1, ListNode head2) {
    ListNode cur1 = head1, cur2 = head2;
    while (cur1 != cur2) {
        // cur1为空时指向head2
        cur1 = (cur1 == null) ? head2 : cur1.next;
        // cur2为空时指向head1
        cur2 = (cur2 == null) ? head1 : cur2.next;
    }
    return cur1;
}
```

### 其他题目

#### 寻找链表中间结点[876.简单]

**题目描述:** https://leetcode-cn.com/problems/middle-of-the-linked-list

给定一个带有**头结点** head 的非空单链表, 返回链表的**中间结点**. 如果有两个中间结点, 则返回**第二个中间结点**. 

```java
输入: [1,2,3,4,5]   输出: 结点 3 
输入: [1,2,3,4,5,6] 输出: 结点 4 
```

**题解1: 单指针法**

使用单个指针, **遍历两次**即可. 

```java
public ListNode middleNode(ListNode head) {
    // 第一次遍历求链表长度
    int n = 0;
    ListNode cur = head;
    while (cur != null) {
        n++;
        cur = cur.next;
    }
    // 第二次遍历只走一半
    n = n / 2;
    cur = head;
    while (n > 0) {
        n--;
        cur = cur.next;
    }
    return cur;
}
```

**题解2: 双指针法**

使用**快慢双指针**, 快指针一次走两步, 慢指针一次走一步. **当快指针到链尾部, 慢指针就在中间了. ** 具体图示参考基础部分. 

```java
public ListNode middleNode(ListNode head) {
    // 快慢指针都在头部
    ListNode slow = head; 
    ListNode fast = head;
    
    // 迭代退出条件
    while (fast != null && fast.next != null) {
        // 快慢指针各自移动
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
```

#### 判断链表是否是回文结构[234.简单]

**题目描述:** https://leetcode-cn.com/problems/palindrome-linked-list/

请判断一个链表是否为**回文链表**. 

```java
输入: 1->2        输出: false
输入: 1->2->2->1  输出: true
```

**题解1: 压栈法**

将链表结点全部**压栈**, 然后逐渐**弹栈**依次与原链表进行比较. 需要空间为 O(N) . 

**题解2: 半边压栈法**

不需要把链表全部压栈, 只需要把链表的**一半**元素压栈即可. 这个方法需要找到链表的**中间结点**, 找的方式可以使用**双指针**. 

**题解3: 逆转链表法**

首先使用**双指针**方式找到链表**中间结点**, 然后从此处**反转**链表的**右半部分**, 使其最后**指向中间结点**, 然后从两边的**两侧同时开始移动**比较, 最后**恢复**链表右边的结构为原样. 这个过程虽然复杂但是空间复杂度为 **O(1)**. 这里寻找链表中点的方法与图解参考基础部分.  

这个方法在多线程环境下可能会出问题, 因为中间涉及到链表结构的修改. 

```java
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }

    // 快慢指针寻找链表中点
    ListNode fast = head;
    ListNode slow = head;

    while (fast.next != null && fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }

    // 记录第二部分的起始结点
    ListNode secondHead = slow.next;
    // 逆序第二部分
    secondHead = reverse(secondHead);

    // 快慢指针重新指向两条链表的开头
    ListNode cur1 = head;
    ListNode cur2 = secondHead;

    // 持续比较
    boolean res = true;
    while (cur1 != null && cur2 != null) {
        if (cur1.val != cur2.val) {
            res = false;
        }
        cur1 = cur1.next;
        cur2 = cur2.next;
    }

    // 还原原始链表
    slow.next = reverse(secondHead);
    return res;
}

public ListNode reverse(ListNode head) {

    if (head == null || head.next == null) {
        return head;
    }
    ListNode newHead = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

#### 链表的插入排序[147.中等]

**题目描述**: https://leetcode-cn.com/problems/insertion-sort-list/

对链表进行**插入排序**. 

```
输入: 4->2->1->3
输出: 1->2->3->4
```

**题解1: 插入排序法**

与传统插入排序不同, **无法**对已排序链表**从尾至首遍历**进行插入. 这里选择**从头往后**遍历进行插入.

- 引入值为**无穷小**的 dummy 结点. 
- 对已排序链表部分**从首至尾**遍历, 找到所有**小于当前遍历元素的位置**, 将当前元素进行插入.

<img src="assets/image-20220716133556221.png" alt="image-20220716133556221" style="zoom:43%;" />

代码如下:

 ```java
public ListNode insertionSortList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    // 引入dummy结点并设置值为最小值
    ListNode dummy = new ListNode(Integer.MIN_VALUE);
    // cur用于寻找插入位置
    ListNode cur = dummy;

    while (head != null) {
        // 找到可以插入的位置
        while (cur.next != null && cur.next.val < head.val) {
            cur = cur.next;
        }
        // 修改指针实现结点插入
        ListNode temp = head;
        head = head.next;
        temp.next = cur.next;
        cur.next = temp;
        // 一次插入完成, cur重新指向dummy
        cur = dummy;
    }
    return dummy.next;
}
 ```

#### 排序链表[148.中等]

**题目描述:** https://leetcode-cn.com/problems/sort-list

在 **O(NlogN)** 时间复杂度和**常数级空间**复杂度下, 对**链表进行排序**. 

```java
输入: 4->2->1->3		输出: 1->2->3->4
输入: -1->5->3->4->0  输出: -1->0->3->4->5
```

**题解1: 递归归并排序**

根据时间复杂度可以想到**二分法**, 从而联想到**归并**排序. 

- **分割 cut 环节**: 找到当前链表**中点**, 并从中点将链表**断开**(以便在下次递归 cut 时, 链表片段拥有**正确边界**); 可以使用 fast, slow 快慢**双指针法**, **奇数个节点找到中点**, 偶数个节点找到**中心左边的节点**. 找到中点 slow 后, 执行 slow.next = null 将链表**切断**. 递归分割时, 输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp (因为链表是从 slow 切断的). cut 递归终止条件: 当 head.next == null 时, 说明只有一个节点了, 直接返回此节点. 参考"**寻找链表中点**"代码.
- **合并 merge 环节**: 参考**合并两个有序链表**部分代码. 

<img src="assets/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png" alt="Picture2.png" style="zoom: 40%;" />

```java
public ListNode sortList(ListNode head) {
    // Base case
    if(head == null || head.next == null) {
        return head;
    }

    // 寻找链表中点
    ListNode fast = head;
    ListNode slow = head;
    while (fast.next != null && fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }

    // 第二部分的开头并断开两部分的指针
    ListNode secondHead = slow.next;
    slow.next = null;

    // 分治, 递归调用
    ListNode slowTemp = sortList(head);
    ListNode fastTemp = sortList(secondHead);

    return merge(slowTemp, fastTemp);
}

// 归并操作-合并两个排序链表
public ListNode merge(ListNode list1, ListNode list2) {

    if (list1 == null || list2 == null) {
        return list1 != null ? list1 : list2;
    }

    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;

    // 都不为空才遍历
    while (list1 != null && list2 != null) {
        // 分情况取两个链表的头结点
        if (list1.val < list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        // 移动cur指针到末尾并断开其对后面链表的连接
        cur = cur.next;
        cur.next = null;
    }

    // 到这里说明其中一个链表为null了 连接上后面的即可
    if (list1 == null) cur.next = list2;
    if (list2 == null) cur.next = list1;

    return dummy.next;
}
```

#### 复制结点带有随机指针的链表[138.中等]

**题目描述:** https://leetcode-cn.com/problems/copy-list-with-random-pointer

给定一个链表, 每个节点包含一个额外增加的**随机指针**, 该指针可以指向链表中的**任何节点或空节点**. 要求返回这个链表的 **深拷贝**. 用一个由 n 个节点组成的链表来表示输入/输出中的链表. 带有随机指针的结点类如下: 

```java
class Node {
    int val;
    Node next;
    // 随机指针
    Node random;
    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
```

**题解1: Map法**

使用一个 **Map** 来保存**原有结点与副本结点的对应关系**, 然后根据原结点的关系从 map 中取对应的副本结点**并设置关系**. map 中的结点的**指针关系依然没变**. 

```java
private static RandomListNode copyListWithRandomPointer(RandomListNode head) {
    // 使用Map存储原始节点与对应复制后节点的关系
    HashMap<RandomListNode, RandomListNode> nodeMap = new HashMap<>();

    // 遍历第一次将全部节点放入map中, map中结点的指针关系依然没变
    RandomListNode cur = head;
    while (cur != null) {
        nodeMap.put(cur, new RandomListNode(cur.value));
        cur = cur.next;
    }
    
    cur = head;
    // 不断从map中取之前的节点设置副本的关系
    while (cur != null) {
        nodeMap.get(cur).next = nodeMap.get(cur.next);
        nodeMap.get(cur).random = nodeMap.get(cur.random);
        cur = cur.next;
    }
    return nodeMap.get(head);
}
```

时间, 空间复杂度均为 **O(N)**. 

**题解2: 迭代复制法(空间较优)**

空间复杂度降为 **O(1)**. 

- 遍历两次, 第一次遍历在每个节点的后面**复制一个值一样的结点**. 

- 第二次遍历时根据原有结点的**随机指针设置复制后的随机指针**(因为原结点与复制结点是挨着的, 所以**有位置关系**). 

- 最后将复制后的链表与原链表**完全分开**即可(这是必须要做的!!!). 

<img src="assets/image-20220716233553810.png" alt="image-20220716233553810" style="zoom:50%;" />

代码如下.

```java
public Node copyRandomList(Node head) {
    // Base case
    if (head == null) return null;
    // 为每个结点再复制一次
    Node cur = head;
    while (cur != null) {
        Node temp = new Node(cur.val);
        temp.next = cur.next;
        cur.next = temp;
        cur = cur.next.next;
    }

    // 复制随机指针
    cur = head;
    while (cur != null) {
        // 随机指针为空的不管
        if (cur.random != null) {
            // 拷贝当前节点的随机指针的指向
            cur.next.random = cur.random.next;
        }
        // 移动两步
        cur = cur.next.next;
    }
    // 将两条链表完全拆分
    cur = head;
    Node copyHead = cur.next;
    Node copyCur = copyHead;
    while (copyCur.next != null) {
        // 移动原链表指针
        cur.next = cur.next.next;
        cur = cur.next;
        // 移动复制链表指针
        copyCur.next = copyCur.next.next;
        copyCur = copyCur.next;
    }
    // 结束标志null
    cur.next = null;
    return copyHead;
}
```

#### 链表子序列组件个数[817.中等]

**题目描述:** https://leetcode-cn.com/problems/linked-list-components

给定一个链表(链表结点包含一个整型值)的**头结点 head**. 同时给定**列表 G**, 该列表是上述链表中整型值的**一个子集**. 返回列表 G 中**组件的个数**, 这里对组件的定义为: 链表中一段**最长连续结点**的值(该值必须在列表 G 中)构成的集合. 

```java
输入: head: 0->1->2->3  G = [0, 1, 3]
输出: 2 解释: 链表中 0 和 1 是相连接的, 且 G 中不包含 2, 所以 [0, 1] 是 G 的一个组件, 同理 [3] 也是一个组件, 故返回 2. 
    
输入: head: 0->1->2->3->4  G = [0, 3, 1, 4]
输出: 2 解释: 链表中, 0 和 1 是相连接的, 3 和 4 是相连接的, 所以 [0, 1] 和 [3, 4] 是两个组件, 故返回 2. 
```

注意是求组件个数而非最长的连续结点数.

**题解1: 辅助set法**

利用**额外空间**进行辅助解答. 首先将数组内容放入一个 **Set** 中, 用于判断**是否包含**该元素. 遍历**链表**, 每个结点都去 Set 中看是否包含这个值. 如果当**前值在 set 中但是下一个值不在 set 中**, 则找到一个组件. 注意需要处理变量到末尾的情况. 

```java
public int numComponents(ListNode head, int[] nums) {
    // 引入Set
    Set<Integer> set = new HashSet();
    for (int num: nums) {
        set.add(num);
    }

    ListNode cur = head;
    int res = 0;

    while (cur != null) {
        // 如果set包含这个值但不包含下一个值,则组件+1
        if (set.contains(cur.val)) {

            // 已经到链表末尾,当前的也算一个组件
            if (cur.next == null) {
                res++;
                break;
            }

            // 如果下一个值不包含则找到一个组件
            if (!set.contains(cur.next.val)) {
                res++;
            }
        }
        cur = cur.next;
    }
    return res;
}
```

简写:

```java
public int numComponents(ListNode head, int[] nums) {
    // 引入Set
    Set<Integer> set = new HashSet();
    for (int num: nums) set.add(num);

    ListNode cur = head;
    int res = 0;

    while (cur != null) {
        // 如果set包含这个值但不包含下一个值 则计数器+1
        if (set.contains(cur.val) && (cur.next == null || !set.contains(cur.next.val))) {
            res++;
        }
        cur = cur.next;
    }
    return res;
}
```

#### 二进制链表转整数[1290.简单]

**题目描述:** https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer

给一个**单链表**的引用结点 head. 链表中每个结点的值不是 0 就是 1. 已知此链表是一个整数数字的**二进制**表示形式. 返回该链表所表示数字的十进制值. 

<img src="assets/graph-1.png" alt="img" style="zoom:70%;" />

```java
输入: head = [1,0,1]  输出: 5
解释: 二进制数 (101) 转化为十进制数 (5)
```

链表的结点总数不超过 30.

**题解1: 位运算法**

利用**二进制转十进制**的算法, 一次遍历即可. 

```java
public int getDecimalValue(ListNode head) {
    // 求和
    int sum = 0;
    while(head != null){
        // 每一位都乘2+原来的值
        sum = sum * 2 + head.val;
        head = head.next;
    }
    return sum;
}
```

**题解2: 库函数解**

直接进行解析. 

```java
public int getDecimalValue(ListNode head) {
    StringBuilder s = new StringBuilder();
    while(head != null) {
        s.append(head.val);
        head = head.next;
    }
    return Integer.parseInt(s.toString(), 2);
}
```









