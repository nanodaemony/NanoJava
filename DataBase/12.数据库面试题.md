[TOC]

### 数据库面试题

#### 一条SQL语句执行得很慢的原因有哪些？

分以下两种情况来讨论。**1. 大多数情况是正常的，只是偶尔会出现很慢的情况。2. 在数据量不变的情况下，这条 SQL 语句一直都执行的很慢。**

##### 1.偶尔很慢的情况

一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，这条 SQL 语句本身应该是没什么问题的，可能是其他原因导致慢查询的。

###### (1)等待数据库刷新脏页

当需要往数据库插入或者更新一条数据的时候，数据库会在**内存**中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到**磁盘**中去，而是把这些**更新的记录写入到 redo log 日志**中去，等到**空闲**的时候，再通过 redo log 里的日志把最新的数据同步到**磁盘**中去。

当**内存数据页**跟**磁盘数据页**内容不一致的时候，可以称这个内存页为 "**脏页**"。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为 "**干净页**"。偶尔执行很慢可能是数据库在**刷脏页**。刷脏页有下面 4 种场景(后两种一般不会导致查询变慢)：

- **redo log 写满：**redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满，这个时候只能暂停其他操作来把**数据同步到磁盘中**去的，而这个时候，**就可能导致平时正常的 SQL 语句突然执行的很慢**。
- **内存不够用了：**如果一次查询较多的数据，恰好碰到所查**数据页不在内存中**时，需要申请内存，而此时恰好内存不足的时候就需要**淘汰一部分内存数据页**，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。
- 此外还有 **MySQL 认为系统 "空闲" 的时候：**这时系统没什么压力。以及 **MySQL 正常关闭的时候：**这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。

###### (2)等待锁

如果要执行的语句所涉及到的**表**别人在用，并且**加锁**了，拿不到锁的时候就只能慢慢等待锁的释放。如果要判断是否真的在等待锁，可以用 **show processlist** 这个命令来查看当前的状态。

##### 2.一直都很慢的情况

###### (1)索引失效

SQL 操作的字段**没有建立索引**，只能走全表扫描。或者建立了索引但是因为一些原因导致**索引失效**。

#### 如何解决秒杀的性能问题和超卖？

抢订单环节一般会带来高并发与超卖的问题。

##### 1.使用Redis

将存库 MySQL 前移到 Redis 中，所有的**写操作放到内存**中，由于 Redis 中**不存在锁**故不会出现互相等待，并且由于 Redis 的写性能和读性能都远高于 MySQL，这就解决了**高并发**下的性能问题。然后通过**队列等异步手段**，将**变化的数据异步写入到 DB 中。**

优点：解决性能问题。缺点：没有解决超卖问题，同时由于异步写入 DB，存在某一时刻 DB 和 Redis 中**数据不一致**的风险。

##### 2.使用队列

**引入队列，然后将所有写 DB 操作在单队列中排队，完全串行处理。当达到库存阀值的时候就不在消费队列，并关闭购买功能。这就解决了超卖问题。**

优点：解决超卖问题，略微提升性能。缺点：性能受限于队列处理机处理性能和 DB 的写入性能中最短的那个，另外多商品同时抢购的时候需要准备**多条队列**。

##### 3.两段式提交

将**提交操作变成两段式**，**先申请后确认**。然后利用 Redis 的**原子自增操作**(相比较 MySQL 的自增来说没有空洞)，同时利用 Redis 的事务特性来发号，**保证拿到小于等于库存阀值的号的人都可以成功提交订单**。然后数据**异步**更新到 DB 中。

优点：解决超卖问题，库存读写都在内存中，故同时解决性能问题。缺点：由于异步写入 DB，可能存在数据不一致。另可能存在少买，也就是如果拿到号的人不真正下订单，可能库存减为 0，但是订单数并没有达到库存阀值。



#### 参考资料

- [库存扣多了，到底怎么整 | 架构师之路](https://mp.weixin.qq.com/s/waGRvyhab2z8b-BIw9bJeA)
- [如何解决秒杀的性能问题和超卖的讨论 - CSDN博客](https://blog.csdn.net/zhoudaxia/article/details/38067003)

