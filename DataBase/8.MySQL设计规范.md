[TOC]

### MySQL规范

#### 数据库命名规范

- 所有数据库对象名称必须使用**小写字母**并用下划线分割。
- 所有数据库对象名称禁止使用 MySQL 保留关键字，如果查询的列名包含关键字时，需要将其用单引号括起来。
- **临时库表必须以 tmp 为前缀**并以日期为后缀，**备份表必须以 bak 为前缀**并以日期(时间戳)为后缀。
- 所有**存储相同数据的列名和列类型必须一致**。如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低。

#### 数据库基本设计规范

- **所有表必须使用 InnoDB 存储引擎**。没有特殊要求(即 InnoDB 无法满足的功能如：列存储，存储空间数据等)的情况下，所有表必须使用 InnoDB 存储引擎。
- **数据库和表的字符集统一使用 UTF8**。兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效。如果需要存储 Emoji 表情，需要采用 utf8mb4 字符集。
- 所有表和字段都需要**添加注释**。使用 COMMENT 从句添加表和列的备注，从一开始就进行数据字典的维护。
- **尽量控制单表数据量的大小，建议控制在 500 万行以内**。500 万并不是 MySQL 数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题。可以用**历史数据归档**(应用于日志数据)，**分库分表**(应用于业务数据)等手段来控制数据量大小。
- **谨慎使用 MySQL 分区表**。分区表在物理上表现为**多个文件**，在逻辑上表现为**一个表**；谨慎选择分区键，跨分区查询效率可能更低；建议采用**物理分表**的方式管理大数据。
- **尽量做到冷热数据分离，减小表的宽度**。减少磁盘 IO，保证热数据的内存缓存命中率(表越宽，把表装载进内存缓冲池时所占用的内存也就越大，也会消耗更多的 IO)。更有效利用缓存，避免读入无用的冷数据；把经常一起使用的列放到一个表中，避免过多的联结操作。
- **禁止在表中建立预留字段**。预留字段的命名很难做到见名识义。预留字段无法确认存储的数据类型，所以无法选择合适的类型。对预留字段类型的修改，会对表进行锁定。
- **禁止在数据库中存储图片，文件等大的二进制数据**。通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，十分耗时。大文件通常存储于 **OSS**，数据库只存储**文件地址**信息。
- 禁止在线上做数据库压力测试。
- 禁止从开发环境、测试环境直接连接生产环境数据库。

#### 数据库字段设计规范

> **优先选择符合存储需要的最小的数据类型**

**原因：**列的字段长度越大，建立索引时所需要的**空间**也就越大，这样一个结点中所能存储的索引分叉的数量也就越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。

**a. 将字符串转换成数字类型存储，如：将 IP 地址转换成整形数据**。

**b. 对于非负型的数据(如自增 ID, 整型 IP) 来说，优先使用无符号整型来存储**。

**原因：**无符号相对于有符号可以**多出一倍**的存储空间。

```mysql
SIGNED INT -2147483648 ~ 2147483647 
UNSIGNED INT 0 ~ 4294967295
```

VARCHAR(N) 中的 N 代表的是**字符数**，而不是字节数，使用 UTF8 存储 255 个汉字 VARCHAR(255) = 765 个字节。**过大的长度会消耗更多的内存**。

> **避免使用TEXT，BLOB数据类型，最常见的TEXT类型可以存储64K的数据**

**a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中**

MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使查询性能变得很差。

如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 SELECT * 查询全部字段，而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。

**2、TEXT 或 BLOB 类型只能使用前缀索引**

因为 MySQL[1] 对索引字段长度是有限制的，所以 TEXT 类型只能使用**前缀索引**，并且 TEXT 列**不能有默认值**。

> **避免使用 ENUM 类型**

修改 ENUM 值需要使用 ALTER 语句。ENUM 类型的 ORDER BY 操作效率低，需要额外操作。禁止使用数值作为 ENUM 的枚举值。枚举值维护在代码中就行。

> **尽可能把所有列定义为 NOT NULL 并设置默认值**

**原因：**索引 NULL 列需要额外的空间来保存，所以要占用更多的空间。NOT NULL 可以减少业务中出现 NPE 异常。

> **使用 TIMESTAMP(4 个字节) 或 DATETIME 类型(8 个字节) 存储时间**

TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高。超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储。

> **同财务相关的金额类数据必须使用 DECIMAL 类型**

DECIMAL 类型为**精准浮点数**，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。可用于存储比 BIGINT 更大的整型数据。

#### 数据库SQL开发规范

> **建议使用预编译语句进行数据库操作**

预编译语句可以**减少 SQL 编译时间**，还可以解决动态 SQL 所带来的 **SQL 注入**的问题。只传参数，比传递 SQL 语句更高效。相同语句可以一次解析，多次使用，提高处理效率。

> **避免数据类型的隐式转换**

**隐式转换**可能会导致索引失效如：

```mysql
SELECT NAME, phone FROM customer WHERE id = '111';
```

> **禁止使用 SELECT *, 必须使用 SELECT <字段列表> 查询**

**原因**：查询全部的字段会消耗更多的 CPU 和 IO 以网络带宽资源，且无法使用覆盖索引。

> **禁止使用不含字段列表的 INSERT 语句**

如：

```mysql
# 不可
INSERT INTO VALUES ('a', 'b', 'c');					
# 可
INSERT INTO t(c1, c2, c3) VALUES ('a', 'b', 'c');
```

> **避免使用子查询，可以把子查询优化为 JOIN 操作**

通常子查询在 **IN 子句**中，且子查询中为简单 SQL (不包含 UNION、GROUP BY、ORDER BY、LIMIT 从句) 时，才可以把子查询转化为关联查询进行优化。

**子查询性能差的原因：**子查询的**结果集无法使用索引**，通常子查询的结果集会被存储到**临时表**中，不论是内存临时表还是磁盘临时表**都不会存在索引**，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。

> **避免使用 JOIN 关联太多的表**

对于 MySQL 来说，是存在**关联缓存**的，缓存的大小可以由 **join_buffer_size** 参数进行设置。在 MySQL 中，对于同一个 SQL 多关联(JOIN)一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。

如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。

同时对于关联操作来说，会产生临时表操作，影响查询效率，关联表查询建议不超过 3 个。

> **减少同数据库的交互次数**

数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。

> **WHERE 从句中禁止对列进行函数转换和计算**

对列进行函数转换或计算时会导致索引失效。

**不推荐：**

```mysql
WHERE DATE(create_time) = '20190101';
```

可以自己转换为范围查询：

```mysql
WHERE create_time >= '20190101' AND create_time < '20190102';
```

> **在明显不会有重复值时使用 UNION ALL 而不是 UNION**

- UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作。
- UNION ALL 不会再对结果集进行去重操作。

> **拆分复杂的大 SQL 为多个小 SQL**

- 大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL。
- MySQL 中，一个 SQL 只能使用一个 CPU 进行计算。
- SQL 拆分后可以通过并行执行来提高处理效率。





#### 参考资料

- [MySQL高性能优化规范建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd)



